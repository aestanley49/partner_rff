---
title: "Data Exploration Salafsky"
author: "Annabelle"
date: "June 15, 2020"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

##Set up file structure 
```{r, include = FALSE}
## setup the file structure so that this markdown document is in the main project folder along with the other folders noted below

DataSource <- "./data" # input raw dataset goes here
output.dir <-"./output" # output dataset writes to here
functions.dir <- "./functions" # directory for functions 

source(file.path(functions.dir,'FormatData.R')) # any functions that are called up by this markdown document need to be sourced here
source(file.path(functions.dir,'cleaning_salafsky.R')) # any functions that are called up by this markdown document need to be sourced here

## general functions that need to be read in. I like to put them at the top so they are easier to deal with when they change version (inevitable)
library(plyr) #for function "join_all" also note, there can be issue loading this after dplyr (which is why it's at the top)
library(readr)
library(readxl)
library(tidyverse)
library(janitor) #used in cleaning 
library(stringr)
library(car) #for function qqplot 
library(knitr) #for making tables form kable 
library(data.table) #function setnames() allows to set multiple column names in one line of code 
library(igraph)


```

##load in different datasets
```{r, echo = FALSE, include = FALSE}
CleanData <- read.csv(paste0(DataSource,"/codesalafsky.csv"), stringsAsFactors = FALSE) #removing end piece  ## codesalafsky.csv is the rawest data that function runs on
code <- cleaning_salafsky(CleanData)
sdata <- read_csv(paste(DataSource,"/tableofpartnersandactions.csv", sep = "")) #this csv is produced at end of cleaning_salafsky.R function 
sdata <- sdata %>% select(-X1) #remove X1 column that is getting produced 

tdata <- read.csv(paste0(DataSource,"/Updated_variables.csv"), stringsAsFactors = FALSE) #data provided by tyler 
tdata <- tdata %>%  as_tibble() #now can use stringr packages 
tdata <- tdata %>%  ##cleaning/reformating colunm names --> default is lower_case_snake
                  clean_names()
##

orgtyp_base <- read.csv(paste0("/usr/local/bin/store/partner_rff/data/tableofPandAmanedited.csv"), stringsAsFactors = FALSE, na = "") #issue was that "" is coming up instead of NA
```

<br>



Group bar chart species-threat
- note, M not removed 
```{r message=FALSE}
#doesn't like that I'm not specifying melt variable names (even though there is only one) so removing warnings from knitting 
alldf <- sdata #change variable name 

species <- alldf[,c(2,10:20)] #unable to knit with select so indexed 

eachsp <- species %>% group_by(Scientific.name) %>% summarise_each(funs(sum)) 


allspindf <- eachsp
new <- tdata #need to join with tdata (renamed here)
###new$scientific_name
#select relevant columns
tthreats <- select(new, scientific_name, hab_x_x:threats_addressed_by_conservation_x_x)

###tthreats$scientific_name
#need to join with tdata 
#to do so need to change col name so match 

tthreats <- rename(tthreats, Sciname = scientific_name)
allspindf <- rename(allspindf, Sciname = Scientific.name)

threats <- left_join(allspindf, tthreats, join_by = Sciname)


############### make graph for each threat

#habitat
hab <- threats %>% filter_at(vars(hab_x_x), any_vars(. %in% c(1))) 
hab <- hab[,-c(1,13:20)]
hab_m <- hab %>%  melt(value.name="hab")
ggplot(hab_m, aes(x=variable, y=hab)) + geom_bar(stat = "identity") + theme(axis.text.x = element_text(angle = 30)) + ggtitle("Count of all actions done to species with habitat threat") + scale_x_discrete(name ="Name of Action")

#overutilization
over <- threats %>% filter_at(vars(over_x_x), any_vars(. %in% c(1))) 
over <- over[,-c(1,13:20)]
over_m <- over %>%  melt(value.name="over")
ggplot(over_m, aes(x=variable, y=over)) + geom_bar(stat = "identity") + theme(axis.text.x = element_text(angle = 30)) + ggtitle("Count of all actions done to species with overutilization") + scale_x_discrete(name ="Name of Action")


#pollution
poll <- threats %>% filter_at(vars(poll_x_x), any_vars(. %in% c(1))) 
poll <- poll[,-c(1,13:20)]
poll_m <- poll %>%  melt(value.name="poll")
ggplot(poll_m, aes(x=variable, y=poll)) + geom_bar(stat = "identity") + theme(axis.text.x = element_text(angle = 30)) + ggtitle("Count of all actions done to species with pollution") + scale_x_discrete(name ="Name of Action")

#species–species
spsp <- threats %>% filter_at(vars(spsp_x_x), any_vars(. %in% c(1))) 
spsp <- spsp[,-c(1,13:20)]
spsp_m <- spsp %>%  melt(value.name="spsp")
ggplot(spsp_m, aes(x=variable, y=spsp)) + geom_bar(stat = "identity") + theme(axis.text.x = element_text(angle = 30)) + ggtitle("Count of all actions done to species with species–species threat") + scale_x_discrete(name ="Name of Action")

#environmental stochasticity
env <- threats %>% filter_at(vars(env_x_x), any_vars(. %in% c(1))) 
env <- env[,-c(1,13:20)]
env_m <- env %>%  melt(value.name="env")
ggplot(env_m, aes(x=variable, y=env)) + geom_bar(stat = "identity") + theme(axis.text.x = element_text(angle = 30)) + ggtitle("Count of all actions done to species with environmental stochasticity threat") + scale_x_discrete(name ="Name of Action")

#demographic stochasticity
demo <- threats %>% filter_at(vars(demo_x_x), any_vars(. %in% c(1))) 
demo <- demo[,-c(1,13:20)]
demo_m <- demo %>%  melt(value.name="demo")
ggplot(demo_m, aes(x=variable, y=demo)) + geom_bar(stat = "identity") + theme(axis.text.x = element_text(angle = 30)) + ggtitle("Count of all actions done to species with demographic stochasticity threat") + scale_x_discrete(name ="Name of Action")


#combine into one dataset 
### Should have just used group_by - found the total number for each based on threat type and then joined 
#threat_actions <- join_all(list(hab_m, demo_m, spsp_m, env_m, poll_m, over_m), by='variable', type='left')
#I think this is replicating information when joining, unsure how to fix
#this would be the next step of putting onto 1 dataframe
#tidythreat <- threat_actions %>%  pivot_longer(c(hab, demo), names_to = 'threat', values_to = 'count')

#unsure how to put on same graph- this is from stackoverflow 
require(gridExtra)
plot1 <- qplot(1)
plot2 <- qplot(1)
#grid.arrange(plot1, plot2, ncol=2)
```


plot hists = M 

use facet_wrap 

### Histogram of number of partners per species 
```{r eval=FALSE, include=FALSE}

onlyM <- sdata[which(sdata$type.of.partners == "M"),]

noM <- sdata[-which(sdata$type.of.partners == "M"),]

nopartall <- (sdata %>% group_by(Scientific.name)   #selecting  each species
%>% distinct(partner.in.agreement)    #count how many partners are distinct 
%>% summarise(n())) 
nopartall <- rename(nopartall, all = 'n()')

noM_nopartners <- (onlyM %>% group_by(Scientific.name)   #selecting  each species
%>% distinct(partner.in.agreement)    #count how many partners are distinct 
%>% summarise(n()))  
noM_nopartners <- rename(noM_nopartners, no_M = 'n()')

onlyM_nopartners <- (noM %>% group_by(Scientific.name)   #selecting  each species
%>% distinct(partner.in.agreement)    #count how many partners are distinct 
%>% summarise(n())) 
onlyM_nopartners <- rename(onlyM_nopartners, onlyM = 'n()')

all_numbersofP <- full_join(nopartall, noM_nopartners, by = "Scientific.name")
all_numbersofP <- full_join(all_numbersofP, onlyM_nopartners, by = "Scientific.name")


#put onto graph 
ggplot(all_numbersofP, aes(f0)) + 
  geom_histogram(mapping = aes(x = no_M), stat = "count", fill = "red", alpha = 0.6, position = "dodge") +
  geom_histogram(mapping = aes(x = onlyM), stat = "count", fill = "blue", alpha = 0.6, position = "dodge")
  
  
    geom_histogram(data = all_numbersofP$all, fill = "red", alpha = 0.2) + 
    geom_histogram(data = all_numbersofP$no_M, fill = "blue", alpha = 0.2) +
    geom_histogram(data = all_numbersofP$onlyM, fill = "green", alpha = 0.2)
    
    
    
ggplot(all_numbersofP, aes(f0)) + geom_bar(mapping = aes(x = onlyM, y = count), fill = "blue", alpha = 0.6, position = "dodge", stat = "identity")


ggplot(data = mtcars, aes(x = factor(carb), fill = factor(gear))) +
geom_histogram(position = "dodge")

ggplot(all_numbersofP) + geom_bar(mapping = aes(x = all, y = count), stat = "identity")

ggplot(all_numbersofP) + geom_histogram(mapping = aes(x = no_M),  fill = "blue", alpha = 0.6, position = "dodge") + geom_histogram(mapping = aes(x = onlyM),alpha = 0.6, position = "dodge") + geom_histogram(mapping = aes(x = all), alpha = 0.6, fill = "red", position = "dodge")

```


Make Network for each type of org 

start from
- managed to get df where all cells were lists (even though some said NULL?) was trying to unlist everything and then went pear shaped.. try and pick up from there 

```{r}
#filter out all rows that don't have values 
orgtyp <- orgtyp_base[-which(is.na(orgtyp_base$type_of_org)),] #this isn't doing anything, lets try again
#remove excess columns

orgtyp2 <- orgtyp[,c(2,3,8)]

tidy_orgtyp <- orgtyp2 %>% group_by(Scientific.name) %>% pivot_wider(names_from = type_of_org, values_from = Scientific.name)
#now have dataframe with org types as columns and cell values of species names so can go through species by species and see when two org columns have same value (species)


#to count the number of times partners in an org type work on species, would have to either use this vector: 
##getscinamesback <- orgtyp %>%  left_join(tidy_orgtyp, by = 'Common.name')
#or count number of strings in cell 
#### Count the number of 'a's in each element of string
#####q.data$number.of.a <- str_count(q.data$string, "a")

#convert to df 
orgtyp <- as.data.frame(tidy_orgtyp)

e <- tidy_orgtyp %>% mutate_all(na_if, "NULL")

f <- as.data.frame(e)

f[!is.na(f)] <- 1
f[is.na(f)] <- 0

#remove first column 
f <- f[,-c(1)]

dim(f)

### make adjacency matrix 
f <- as.matrix(f) 
#indexing is werid and matrix mult won't work so will try and write to csv 

write.csv(f, "/usr/local/bin/store/partner_rff/output/orgtype_adjmat.csv")

g <- read.csv(paste0("/usr/local/bin/store/partner_rff/output/orgtype_adjmat.csv"), stringsAsFactors = FALSE)
#remove first column 
g <- g[,-c(1)]

tg <- (t(g))

write.csv(tg, "/usr/local/bin/store/partner_rff/output/orgtype_adjmat_part2.csv")

h <- read.csv(paste0("/usr/local/bin/store/partner_rff/output/orgtype_adjmat_part2.csv"), stringsAsFactors = FALSE)
#remove first column 

rownames(h) <- h$X #set partnernames as rownames
h[,1] <- NULL #then remove column 

orgtype_adjmat <- as.matrix(h) %*% as.matrix(g)


################### set up network 
```

```{r}


tadjmat <- orgtype_adjmat

tadjmat[lower.tri(tadjmat)] <- NA
diag(tadjmat) <- NA

tolist <- tadjmat %>% melt() 
tolist <- tolist[-which(is.na(tolist$value)),]


#library(igraph)

net <- graph_from_data_frame(d=tolist, directed=T) 


E(net)$arrow.size <- .2 #determine size of arrows (this makes the heads real small so they are more like lines)
#V(net)$names <- c("a","b","c","d","e","f","g","h") #naming the nodes -- try this later so don't over write what actal names are 
#V(df)$names <- c("hab_x_x", "over_x_x", "poll_x_x", "spsp_x_x", "env_x_x", "demo_x_x")



node.size<-setNames(c(4,4,11,5,14,11,30,7,6,3,4,4,4,12), c("C","M","P","SL","SW","BLM","USFWS","FO","N","SB","O","R","SG","USFS"))
  #so not setting in the same order 
#V(net)$label <- NA
E(net)$width <- E(net)$value

plot(net, vertex.size=node.size)

l <- l <- layout_with_fr(net)
plot(net, vertex.size=node.size, layout = l)

```
Caption: 
node = org type
node size = # of species that all parnters categorized as that org works on
edge width = # of species two orgs work on together 


Network for each org
```{r}

base <- orgtyp_base
base <- base[,-c(4:7,9:12)]

base <- base[-which(is.na(base$type_of_org)),] #remove rows with multi-partner strings

#would be super easy with a loop 

```
Caption:
Network for each org where 
nodes are actions
node size - number of times action is done
Edge - number of partnerships that apply both types of actions














```{r eval=FALSE}


############################# Yay that works!! Now just need to make into matrix, multiple and then network (all below is scrap work)


#new issue is that all cells (except for first row) is in list

b <- lapply(orgtyp, function(x) ifelse(length(x)==0,0,x))

c <- lapply(orgtyp, function(x) if (length(x) == 0) {0} else {x})


myFUN <- function(x) {
    if ((character(x)) >= 1) {
      1
    } else {
      0
    }
  } 


d <- myFUN(orgtyp)

### original thought was to replace empty lists with 0s but none of these are working 
## looks like thats because length wasn't 0 but 1
##Issue is that all lists in df have length of 1
### New plan is to try and replace by class

orgtyp[lengths(orgtyp) == 1] <- 0


myFun <- function(data) {
  temp1 <- sapply(data, is.list)
  temp2 <- do.call(
    cbind, lapply(data[temp1], function(x) 
      data.frame(do.call(rbind, x), check.names=FALSE)))
  cbind(data[!temp1], temp2)
}

myFun(orgtyp)

neworgtyp <- (apply(orgtyp, 1, unlist))

neworgtyp <- t(neworgtyp)

orgtype2 <- cbind(orgtyp[!sapply(orgtyp, is.list)], 
      (t(apply(orgtyp[sapply(orgtyp, is.list)], 1, unlist))))


is.null(orgtyp[2,2])

orgtyp[1,5]

#for now, just going to convert to 1s and 0s 
orgtyp[is.null(orgtyp)] <- 0
tidy_orgtyp[!is.na(tidy_orgtyp)] <- 1

tidy_orgtyp[2,2]


```

```{r}

```

