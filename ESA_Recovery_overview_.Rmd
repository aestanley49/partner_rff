---
title: "ESA_Recovery_overview_doc"
author: "Annabelle"
date: "6/7/2021"
output:
  word_document: default
  html_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

##Introduction 
We are trying to answer the following Qs (which are the same as in the "Overview" doc)
1.	What are the conservation initiatives for a species 
2.	What are the actions specified in the federal register important for the species? 
3.	Who are the organizations/players involved in doing these conservation initiatives? 
4.	What are the actions each organization is doing (optional?)

This document has the summary statistics for questions 1 & 2 (added 06/07/2021) and each section is question specific 

Notes
- Slight issue - missing at least 10 species data from tyler for initial draft of data (10 out of 38 species) ... is this data accessible from the drives?? 


##Set up file structure 
```{r, include = FALSE, echo = FALSE}
## setup the file structure so that this markdown document is in the main project folder along with the other folders noted below

DataSource <- "./data" # input raw dataset goes here
output.dir <-"./output" # output dataset writes to here
functions.dir <- "./functions" # directory for functions 

#source(file.path(functions.dir,'FormatData.R')) # any functions that are called up by this markdown document need to be sourced here
# we don't have any functions for this dataset yet... 


library(plyr) #for function "join_all" also note, there can be issue loading this after dplyr (which is why it's at the top)
library(readr)
library(readxl)
library(tidyverse)
library(dplyr)
library(janitor) #used in cleaning 
library(stringr)
library(knitr) #for making tables form kable 
library(data.table) #function setnames() allows to set multiple column names in one line of code 
library(corrplot) #for visualizing chi square results 
library(reshape) # has melt function
library(skimr) #super nice summary package 
library(car) #contains vif function 
library("stargazer")
library(fmsb) #for pairwise fisher's test
library("rstatix") ## for fisher's exact 
library(lmtest) ## for heteroskedasticity 
library(car) #function qqPlot - car
library(sandwich) # for resolving heteroskedasticity
library("relaimpo") # for partial R2ed calcs
library(heplots) # different type of R2ed calc
library(rsq) # third type of R2ed calcs
```

##load in different datasets
```{r, echo = FALSE, include = FALSE}
initiatves_partners <- read_excel(paste0("/usr/local/bin/store/partner_rff/data/AS12_Jun_15_21_codingdata.xlsx"), sheet = "initiatves_partners", trim_ws = T, col_names = T, na = c("", " ", "NA") #issue was that "" is coming up instead of NA
               )

proactive <- read_excel(paste0("/usr/local/bin/store/partner_rff/data/AS12_Jun_15_21_codingdata.xlsx"), sheet = "threats", trim_ws = T, col_names = T, na = c("", " ", "NA") #issue was that "" is coming up instead of NA
               )

confidence <- read_excel(paste0("/usr/local/bin/store/partner_rff/data/AS12_Jun_15_21_codingdata.xlsx"), sheet = "metadata", trim_ws = T, col_names = T, na = c("", " ", "NA") #issue was that "" is coming up instead of NA
               )


### OLD Tyler datasets
#dataset that tyler sent, contains a number of predictors 
tdataOLD <- read.csv(paste0(DataSource,"/Updated_variables.csv"), stringsAsFactors = FALSE) #shared by tyler
tdataOLD <- tdataOLD %>%  as_tibble() #now can use stringr packages 
tdataOLD <- tdataOLD %>%  ##cleaning/reformating colunm names --> default is lower_case_snake
                  clean_names()
plustwo <- read.csv(paste0(DataSource, "/two_additional_species.csv"), stringsAsFactors = FALSE) #additional two species not in tdata

### NEW Tyler datasets
## replacing all_tyler_data_6_12_21 with all_tyler_manuscript_data_6_27_21 now have %public private calculations
tdata <- read.csv(paste0(DataSource,"/all_tyler_manuscript_data_6_27_21.csv"), stringsAsFactors = FALSE) #shared by tyler
tdata <- tdata %>%  as_tibble() #now can use stringr packages 
tdata <- tdata %>%  ##cleaning/reformating colunm names --> default is lower_case_snake
                  clean_names()

```


##Modify datasets
```{r, echo = FALSE, include = FALSE}
initiatves_partners <- initiatves_partners[,-c(30:80)] # not using the end of this data sheet

## Subset only for species that we are using (this was decided by placing an "x" in the first column) so..
sub_initiatves_partners <- initiatves_partners[which(initiatves_partners$post_5_25 == "x"),]

## removal all NAs for "RowSpecificInfo"
sub_initiatves_partners <- sub_initiatves_partners[-which(is.na(sub_initiatves_partners$RowSpecInfo)),]

################

##### get the same species set that we use in dataset above by.. 
## getting names of species in initiatives subset 
sub_initiatves_partners <- initiatves_partners[which(initiatves_partners$post_5_25 == "x" | initiatves_partners$post_5_25 == "X"),]

sub_initiatves_partners <- sub_initiatves_partners[-which(is.na(sub_initiatves_partners$RowSpecInfo)),]

names <- sub_initiatves_partners[,c(3,4)]
names <- names %>% distinct(scientific_name)
## then joining with proactive dataset 

proactive <- left_join(names, proactive)

FR_pg_length_and_doc_type <- proactive %>% select(scientific_name, common_name, FR_pg_length, type_FR_doc)

proactive <- proactive[,-c(3:10, 20:31)] ## removed excess columns 
names <- proactive[,c(1,2)]
#proactive_sub <- proactive[,-c(1,2)]
#change all values to 1s and 0s

proactive <- as.data.frame(proactive)
proactive[!is.na(proactive)] <- 1
proactive[is.na(proactive)] <- 0

proactive <- proactive[,-c(1,2)]

proactive2 <- cbind(names, proactive)


##### Need to pull in range, threats and taxa information for species 

```


##Modify datasets Tyler 
Variables needed: 
  # range size --> area c32 
  # area weighted footprint --> c33 ?have options
  # total threat count --> c 26
  # type of threat --> c27
  # employment (all relevant industries) -> 55:59 [avg_employment ???]
  # percent public and percent federal c66, c68 
  # diversity of landowners - shannons H (land use complextity)
  # taxa (plants v animals // vert v invert) taxa c16
  # percent public private lands now added (6/27)

missing species (presumming Tyler dropped them..)
  # Euphilotes pallescens arenamontana
  # Nysius wekiuicola

Species Name changes/differences accross datasets 
Chorizanthe parryi var fernandina -> Chorizanthe parryi var. fernandina
Moxostoma sp 2 -> Moxostoma sp.
  
```{r, include = FALSE, echo = FALSE}

tdata_mod <- tdata %>% select(scientific_name, common_name, vert_vs_invert, species_group, number_of_counties, range_area, habitat_modification, overutilization, pollution, species_species_interactions, env_stochasticity, demographic_stochasticity, total_threats, public_mang_shannons_diversity, private_land_proportion, weighted_rural)

#put together with current list of species [doing Proactive dataset - may need to merge again]

t_pro_df <- left_join(proactive2, tdata_mod, by = c("scientific_name"))
t_pro_df <- t_pro_df %>% select(-common_name.y)
t_pro_df$common_name <- t_pro_df$common_name.x
t_pro_df <- t_pro_df %>% select(-common_name.x)

## Need to add values for % public/ private (located in tdata) bc not in new dataset 
## AND get info for species that have been recently removed from tyler's current dataset 

#percent_data <- tdataOLD %>% select(scientific_name, common_name, percentpublic:percentfederal)

#df <- left_join(t_pro_df, percent_data, by = c("common_name"))
#df <- df %>% select(-scientific_name.y)
#df$scientific_name <- df$scientific_name.x
#df <- df %>% select(-scientific_name.x) #changing col name back

## Need to rearrange column order

df <- t_pro_df[,c(25,1:20,21,22:24)]

```



## 1.	What are the conservation initiatives for a species 

#### 1 - Summary stats

- Number of iniatitves per species
- # iniatives per species (mean, median, quartiles)
- Count of efforts, agreements, groups per species 


```{r, include = FALSE, echo = FALSE,  warning=FALSE}
#### - Number of initiatives per species

#number of partners in each of the agreements
no_init_per_sp <- sub_initiatves_partners %>% group_by(common_name, RowSpecInfo) %>% distinct(Agreement_Name) %>%    #count how many names are distinct 
summarise(n())

## number of initiatives per species 
no_init_per_sp$count <- no_init_per_sp$`n()` 
no_init_per_sp_2 <- no_init_per_sp %>% group_by(common_name) %>%
summarize(sum = sum(count))

ggplot(no_init_per_sp_2) + geom_bar(mapping = aes(x = reorder(common_name, -sum), y = sum), stat = "identity")+ theme(axis.text.x = element_text(angle = 90)) + ggtitle("Number of initiatives per species") + scale_x_discrete(name ="Species") + scale_y_continuous(name ="Count")


##### - # iniatives per species (mean, median, quartiles)

summary(no_init_per_sp_2)
  

##### - Count of efforts, agreements, groups per species

no_init_per_sp <- sub_initiatves_partners %>% group_by(common_name, RowSpecInfo) %>% distinct(Agreement_Name) %>%    #count how many names are distinct 
summarise(n())

## need to figure out how to add "Landowner" and "document" to other categories to count types of efforts 
no_init_per_sp[which(no_init_per_sp$RowSpecInfo == "Land Owner"),2] <- "Effort"
no_init_per_sp[which(no_init_per_sp$RowSpecInfo == "Document"),2] <- "Agreement"

no_init_per_sp$count <- no_init_per_sp$`n()` 

no_init_per_sp_3 <- no_init_per_sp %>% group_by(common_name, RowSpecInfo) %>%
summarize(sum = sum(count))


ggplot(no_init_per_sp_3, aes(common_name, sum)) +   
  geom_bar(aes(fill = RowSpecInfo), position = "stack", stat="identity") + theme(axis.text.x = element_text(angle = 0)) + ggtitle("Number of initiatives per species") + scale_x_discrete(name ="Species") + scale_y_continuous(name ="Count") + coord_flip()


## Sum stats 
sum(no_init_per_sp_2$sum)
## [1] 185

summary(no_init_per_sp_2$sum)

sumstat <- no_init_per_sp_3

sumstat <- pivot_wider(sumstat, names_from = RowSpecInfo, values_from = sum)

sum(sumstat$Agreement, na.rm = T)
sum(sumstat$Effort, na.rm = T)
sum(sumstat$Group, na.rm = T)

```

#### 1 - Regression Predictor Modification
-	Working group mentioned – logistic regression
-	Numbers of efforts or agreements – linear regression or negative binomial or poisson regression (since count data)

```{r, include = FALSE, echo = FALSE,  warning=FALSE}
NoIniv <- no_init_per_sp_2 
names(NoIniv) <- c("common_name", "no_iniv")

L_df <- full_join(df, NoIniv)


## taxa (coding for plants)
plant <- c(0)
L_df <- add_column(L_df, plant)
L_df[which(L_df$vert_vs_invert == "P"),27] <- 1

reg_prdctr <- L_df %>% select(scientific_name, common_name, no_iniv, range_area, plant, public_mang_shannons_diversity, total_threats, private_land_proportion, weighted_rural)


## Add FR_pg_length variable and create dummy variables

FR_info <- FR_pg_length_and_doc_type

#type of FR doc - 12 monthns

FR_info <- FR_info %>% mutate(month_12 = case_when(grepl("month", type_FR_doc, ignore.case = TRUE) ~ 1)) %>% 
  replace(is.na(.), 0) # then replace all 0s 

#type of FR doc - withdrawal of proposed rule 
# method used above won't work because strings are all slightly different
# grepl works to slect strings
# case_when is similar to ifelse 

FR_info <- FR_info %>% mutate(wd_proposed = case_when(grepl("withdrawal", type_FR_doc, ignore.case = TRUE) ~ 1)) %>% 
  replace(is.na(.), 0) # then replace all 0s 

#FR page count based on binary variable (1 = if greater than 1 page)
FR_info <- FR_info  %>% mutate(Big_Pg_count = case_when(FR_pg_length > 1 ~ 1, FR_pg_length <= 1 ~ 0 )) 

#select the predictors actually want 
FR_info  <- FR_info %>% select(-FR_pg_length, -type_FR_doc)             


reg_prdctr <- reg_prdctr %>% left_join(FR_info)


names(reg_prdctr) <- c("scientific_name"     ,           "common_name"            ,       
 "no_iniv"        ,                "range_area"         ,           
              "plant"           ,     "public_mang_shannons_diversity",         
 "total_threats"  ,   
 "private_land_proportion"  ,     "weighted_rural"         ,    
 "month_12"         ,              "wd_proposed"    ,               
"Big_Pg_count"      )

skim(reg_prdctr)

reg_prdctr_init <- reg_prdctr


## create logs of range area and # initatives

reg_prdctr_init <- reg_prdctr_init %>% 
  mutate(log_rangearea = log(range_area)) %>% 
  mutate(log_initatives = log(no_iniv))


## re arrange order 

reg_prdctr_init <- reg_prdctr_init %>% select(scientific_name:no_iniv, log_initatives, log_rangearea, range_area:Big_Pg_count)

## removing %public until have all data and Big_pg_count 
reg_prdctr_init <- reg_prdctr_init %>% select(-public_mang_shannons_diversity, Big_Pg_count)


## Need an extra variable to try in the partners model so pulling it here
ns_threats <-  select(tdata, common_name, scientific_name, nserve_pop_stability)

reg_prdctr_init <- reg_prdctr_init %>% left_join(ns_threats, by = "scientific_name")



```


### Base model

```{r Correlation Matrix, include = FALSE, echo = FALSE}
# Correlation Matrix of Predictors vs Responses ##
## modified some code from http://handlesman.blogspot.com/2011/03/matrix-plot-with-confidence-intervals.html
#Not working because of NAs in data - getting error that x is not numeric 


#set up
PredictorsOnlyPixel <- reg_prdctr_init[,c(3)]
PredictAndResponsePixel <- reg_prdctr_init[,-c(1:2)]
PredictAndResponseGrid <- reg_prdctr_init[,-c(1:2)]
  
# put histograms on the diagonal panel	
panel.hist <- function (x,...)					# define a function that says what we want to plot in the diagonal
{
  usr <- par("usr"); on.exit(par(usr))			# not sure what usr is for?
  par(usr = c(usr[1:2],0,1.5))
  h <- hist(x, plot = FALSE)
  breaks <- h$breaks; nB <- length(breaks)			# make the hist 
  y <- h$counts; y <- y/max(y)
  rect(breaks[-nB], 0, breaks[-1], y, col="grey", ...)  # defines what the histogram is going to look like
}

# put correlations on the upper panels,
panel.cor <- function(x, y, digits=2, prefix="", cex.cor, ...)
{
  usr <- par("usr"); on.exit(par(usr))
  par(usr = c(0, 1, 0, 1))
  r <- cor(x, y,use="complete.obs")				
  txt <- format(c(r, 0.123456789), digits=digits)[1]
  prefix <- "r = "
  rc <- cor.test(x,y,method = c("pearson"))				## calculate pearsons rho for upper grid
  txt <- paste(prefix,txt,sep="")
  text(0.5, 0.5, txt, cex = 1)
}

## plot a correlation matrix plot that uses the functions specified above to say what to plot where
      ## this was taken directly from website and still not plotting r values for all 
#pairs(PredictAndResponsePixel[1:6], lower.panel=panel.smooth, cex = .8, diag.panel=panel.hist, cex.labels = 1.2, font.labels=2, upper.panel=panel.cor)

##Pixel level

pairs(PredictAndResponsePixel,lower.panel = panel.smooth, diag.panel=panel.hist,upper.panel=panel.cor)


printme <- pairs(PredictAndResponsePixel,lower.panel = panel.smooth, diag.panel=panel.hist,upper.panel=panel.cor)

##try printing dendrogram so can actually see it 

ggsave(filename = "cormat_initatives.jpg", plot = printme, path = output.dir)


pdf("cormat_initative")
pairs(PredictAndResponsePixel,lower.panel = panel.smooth, diag.panel=panel.hist,upper.panel=panel.cor)
#dev.off()
while (!is.null(dev.list()))  dev.off()

### Predictors only  -->  only have one response so not going to run this one
##pairs(PredictorsOnlyPixel,lower.panel = panel.smooth, diag.panel=panel.hist,upper.panel=panel.cor)


#test correlations to look for covariation between predictors
cor(reg_prdctr[,-c(1:2)], use = "complete.obs") # matrix seems fine
#no na.rm in this one instead it's "use"

```

- Note: percent public variable is still in matrix but was removed from model


VIFS
```{r, include = FALSE, echo = FALSE}
#### Previous
###vif(lm(no_iniv ~ range_area +percentpublic + plant + public_mang_shannons_diversity + total_threats,data = reg_prdctr))

vif(lm(log(no_iniv) ~ range_area + plant  + total_threats + private_land_proportion + weighted_rural, data = reg_prdctr_init))
```

model summary - variations

```{r lm1, include = FALSE, echo = FALSE}
lm1 <- lm(log(no_iniv) ~ range_area + plant  + total_threats,data = reg_prdctr_init)

lm2 <- lm(log(no_iniv) ~ log(range_area) + plant  + total_threats,data = reg_prdctr_init)

lm4 <- lm(log(no_iniv) ~ log(range_area) + plant  + total_threats + Big_Pg_count,data = reg_prdctr_init)

lm6 <- lm(log(no_iniv) ~ log(range_area) + plant  + total_threats + month_12,data = reg_prdctr_init)

lm8 <- lm(log(no_iniv) ~ log(range_area) + plant  + total_threats + wd_proposed,data = reg_prdctr_init)

lm9 <- lm(log(no_iniv) ~ log(range_area) + plant  + total_threats + wd_proposed + month_12,data = reg_prdctr_init)

lm10 <- lm(log(no_iniv) ~ log(range_area) + plant  + total_threats + private_land_proportion,data = reg_prdctr_init)

lm11 <- lm(log(no_iniv) ~ log(range_area) + plant  + total_threats + weighted_rural,data = reg_prdctr_init)

lm12 <- lm(log(no_iniv) ~ log(range_area) + plant  + total_threats + private_land_proportion + month_12,data = reg_prdctr_init)

lm13 <- lm(log(no_iniv) ~ log(range_area) + plant  + total_threats + private_land_proportion + wd_proposed,data = reg_prdctr_init)

lm14 <- lm(log(no_iniv) ~ log(range_area) + plant  + total_threats + private_land_proportion + wd_proposed + month_12,data = reg_prdctr_init)


summary(lm1)
summary(lm2)
summary(lm4)
summary(lm6)
summary(lm8)
summary(lm9)
summary(lm10)
summary(lm11)


AIC(lm1)
AIC(lm2)

AIC(lm4)

AIC(lm6)

AIC(lm8)
AIC(lm9)
AIC(lm10)
AIC(lm11)


#kable(table(lm2$coefficients))

#par(mfrow = c(1, 1))
#plot(lm2)

#qqPlot(residuals(lm2))
#par(mfrow = c(1, 1))

#plot(predicted(lm2), residuals(lm2))
#hist(residuals(lm2))
# how add CI equivalent around q-q plot? 
AIC(lm2)
#check_overdispersion(lm2)
```


Trying stargazer 

```{r, include = FALSE, echo = FALSE}
stargazer(lm1, lm2, lm10, lm11, lm12, lm13, lm14, type = "html", title = "Initiatives_models", align = TRUE, out = "output/Initiatives_models_22_Jun_2021.html", # AIC isn't calculated for lm models so adding manually
          add.lines=list(c("AIC", round(AIC(lm1),1), round(AIC(lm2),1), round(AIC(lm10),1), round(AIC(lm11),1), round(AIC(lm12),1), round(AIC(lm13),1), round(AIC(lm14),1)  ))) 


```



## 2.	What are the actions specified in the federal register important for the species?

#### 1 - Summary stats

Count of outcomes as proactive vs responsive
```{r OLD code, echo = FALSE,  warning=FALSE, include=FALSE}

outcomes <- df

outcomes[,c(3:11)] <- sapply(outcomes[ ,c(3:11)], as.numeric)

### ### ### ### ### setting up data mannipulations (unsure if need) by making new columns  

### ### ### ### Actions
outcomes <- outcomes %>% rowwise() %>% mutate("preempt" = sum(preempt_private, preempt_public, preempt_unclear)) %>% #rowSums with mutate (need rowwise) 
 mutate_at(vars(preempt), ~1 * (. > 0)) #changed all values back to ones and zeros ## this doesn't work because changes whole df 

outcomes <- outcomes %>% rowwise() %>% mutate("react" = sum(respon_private, respon_public, respon_unclear)) %>%  #rowSums with mutate (need rowwise)
  mutate_at(vars(react), ~1 * (. > 0)) #changed all values back to ones and zeros 

outcomes <- outcomes %>% rowwise() %>% mutate("both_react_preempt" = sum(react, preempt)) %>%  #rowSums with mutate (need rowwise)
  mutate_at(vars(both_react_preempt), ~1 * (. >= 2)) # change all specified mutate functions back to ones and zeros 

outcomes <- outcomes %>% rowwise() %>% mutate("react_only" = react - both_react_preempt) #%>%  #rowSums with mutate (need rowwise)
#  mutate_at(vars(react_only), ~"react_only" * (. > 0)) #changed all values back to ones and zeros 

outcomes <- outcomes %>% rowwise() %>% mutate("preempt_only" = preempt - both_react_preempt)

#outcomes %>% mutate(vars(both_react_preempt:preempt_only), funs(ifelse(. == 1, deparse(substitute(.)), .)))

## trying to get a single column with preempt, protect, or both as cell values for ggplot ease
#outcomes$actionresults <- apply(outcomes[,30:32], 1, function(x) max(names(which(x >0))))

## Bar chart Preempt: proactive, protective, both
#ggplot(outcomes, aes(f0)) + 
# geom_histogram(mapping = aes(x = actionresults), stat = "count", fill = "red", alpha = 0.6, position = "dodge")
  

```

Count of outcomes on public vs private land 
```{r OLD, echo = FALSE,  warning=FALSE, include=FALSE}

### ### Land
outcomes <- outcomes %>% rowwise() %>% mutate("public" = sum(preempt_public, public_unclear, respon_public)) %>% #rowSums with mutate (need rowwise) 
 mutate_at(vars(public), ~1 * (. > 0)) #changed all values back to ones and zeros ## this doesn't work because changes whole df 

outcomes <- outcomes %>% rowwise() %>% mutate("private" = sum(respon_private, private_unclear, preempt_private)) %>%  #rowSums with mutate (need rowwise)
  mutate_at(vars(private), ~1 * (. > 0)) #changed all values back to ones and zeros 

outcomes <- outcomes %>% rowwise() %>% mutate("both_public_private" = sum(public, private)) %>%  #rowSums with mutate (need rowwise)
  mutate_at(vars(both_public_private), ~1 * (. >= 2)) # change all specified mutate functions back to ones and zeros 

outcomes <- outcomes %>% rowwise() %>% mutate("public_only" = public - both_public_private) #%>%  #rowSums with mutate (need rowwise)
#  mutate_at(vars(react_only), ~"react_only" * (. > 0)) #changed all values back to ones and zeros 

outcomes <- outcomes %>% rowwise() %>% mutate("private_only" = private - both_public_private)

#outcomes %>% mutate(vars(both_react_preempt:preempt_only), funs(ifelse(. == 1, deparse(substitute(.)), .)))

## trying to get a single column with preempt, protect, or both as cell values for ggplot ease
#outcomes$landresults <- apply(outcomes[,36:38], 1, function(x) max(names(which(x >0))))

## Barchart: 	Land: public, private, both
#ggplot(outcomes, aes(f0)) + 
#  geom_histogram(mapping = aes(x = landresults), stat = "count", fill = "red", alpha = 0.6, position = "dodge")


```



```{r NEW land and actions, echo=FALSE, warning=FALSE}

all <- outcomes

all <- all %>% select(preempt:react, public:private)

names(all) <- c("preempt_yes", "react_yes"  , "public_yes" , "private_yes")

## create the inverse (cases where no)
all <- all %>% 
  mutate(preempt_no = case_when(preempt_yes < 1 ~ 1  )) %>% 
  mutate(react_no = case_when(react_yes < 1 ~ 1  )) %>% 
  mutate(public_no = case_when(public_yes < 1 ~ 1  )) %>% 
  mutate(private_no = case_when(private_yes < 1 ~ 1  )) 


all <- colSums(all[,c(1:8)], na.rm = T) 
all <- as.data.frame(all) %>% rownames_to_column()

all1 <- all %>% separate(rowname, c("one", "two"), "_")  ## seperating into three different columns based on "_"

all2 <- all1 %>%  pivot_wider(names_from = two, values_from = all) ## transforming dataset so have "Yes" and "No" as seperate columns to be set up in same way as Becky's dataset 


test_act <- all2 %>% filter(one == "preempt" | one =="react") %>% 
  select(yes, no)

test_land <- all2 %>% filter(one == "private" | one =="public") %>% select(yes, no)


test_actions <- chisq.test(test_act)
test_actions

test_land_a <- chisq.test(test_land)
test_land_a

fish_actions <- fisher.test(test_act)
fish_actions

fish_land <- fisher.test(test_land)
fish_land


#fish <- row_wise_fisher_test(test_threat_actions, workspace = 2e8, p.adjust.method = "bonferroni")
#fish


ggplot(all1) + aes(x=factor(one), y=all, fill = (two)) +
  geom_bar(stat="identity", position = "stack") +
  ggtitle("Actions and locations") + 
  scale_y_continuous(name = "count")+
  labs(fill = "Yes or No") + 
  scale_x_discrete(limits = c("preempt", "react", "private", "public")) + 
  theme(axis.title.x = element_blank())
  

test_act <- all1 %>% filter(one == "preempt" | one =="react") 

  ggplot(test_act) + aes(x=factor(one), y=all, fill = (two)) +
  geom_bar(stat="identity", position = "stack") +
  ggtitle("Actions and locations") + 
  scale_y_continuous(name = "count")+
  labs(fill = "Yes or No") + 
  scale_x_discrete(limits = c("preempt", "react")) + 
  theme(axis.title.x = element_blank())

test_land <- all1 %>% filter(one == "private" | one =="public") 

ggplot(test_land) + aes(x=factor(one), y=all, fill = (two)) +
  geom_bar(stat="identity", position = "stack") +
  ggtitle("Actions and locations") + 
  scale_y_continuous(name = "count")+
  labs(fill = "Yes or No") + 
  scale_x_discrete(limits = c("private", "public")) + 
  theme(axis.title.x = element_blank())

```




```{r OLD Actions for types of species, echo=FALSE, warning=FALSE, eval=FALSE}
### ### ### ### ### ### Taxa 

taxa <- outcomes
taxa <- taxa %>% select(scientific_name, common_name, preempt_private:species_group, preempt:landresults)

## Filling in missing data 
taxa[which(is.na(taxa$vert_vs_invert)),12] <- c("I")
taxa[which(is.na(taxa$species_group)),13] <- "Insects"   

### ### ### Taxa -- Actions
  ### 	all species, plant species, animal species (outcome: preempt)

taxa_small <- taxa %>% select(scientific_name, actionresults, vert_vs_invert )

## trying to get the following data frame 
#|       | both| preempt | protect|
#|:------|-----|---------|-------:|
#|all sp |     |         |        |
#|plant  |     |         |        |
#|animal |     |         |        |

# Doing so by subsetting by animal type and then will recombine 

plants <- taxa_small %>% filter(vert_vs_invert == "P") %>% ## Select which species type to subset 
pivot_wider(names_from = actionresults, values_from = vert_vs_invert) %>%  ## may action types col names
  as.data.frame() %>%  # turn to dataframe
  replace(!is.na(.), 1)  # convert all values to 1s so can col sum below 
plants[,c(1:5)] <- sapply(plants[ ,c(1:5)], as.numeric)
plants <- colSums(plants[,c(2:5)], na.rm = T)
plants <- as.data.frame(plants) %>% rownames_to_column()

invert <- taxa_small %>% filter(vert_vs_invert == "I") %>% ## Select which species type to subset 
pivot_wider(names_from = actionresults, values_from = vert_vs_invert) %>%  ## may action types col names
  as.data.frame() %>%  # turn to dataframe
  replace(!is.na(.), 1)  # convert all values to 1s so can col sum below 
invert[,c(1:4)] <- sapply(invert[ ,c(1:4)], as.numeric)
invert <- colSums(invert[,c(2:4)], na.rm = T) 
invert <- as.data.frame(invert) %>% rownames_to_column()
  #rownames_to_column() 

vert <- taxa_small %>% filter(vert_vs_invert == "V") %>% ## Select which species type to subset 
pivot_wider(names_from = actionresults, values_from = vert_vs_invert) %>%  ## may action types col names
  as.data.frame() %>%  # turn to dataframe
  replace(!is.na(.), 1)  # convert all values to 1s so can col sum below 
vert[,c(1:3)] <- sapply(vert[ ,c(1:3)], as.numeric)
vert <- colSums(vert[,c(2:3)], na.rm = T) 
vert <- as.data.frame(vert) %>% rownames_to_column()

species <- full_join(plants, vert, by = "rowname")
species <- full_join(species, invert, by = "rowname")
species <- species %>% rowwise() %>%  mutate("all_sp" = sum(plants,vert, invert, na.rm = T))
  
### make bar graph 

s <- species
rownames(s) <- c("NA", "react_only", "both_react_preempt", "preempt_only" )
s <- as.data.frame(s)
#s <- s[,-c(1)]
smelt <- s %>% melt()

ggplot(smelt) + aes(x=variable, y=value, fill = factor(rowname, levels=c("NA", "react_only", "both_react_preempt", "preempt_only"))) +
  geom_bar(stat="identity", position = position_dodge()) + 
  scale_x_discrete(name ="species") + 
  ggtitle("Actions for types of species") + 
  scale_y_continuous(name = "count")+
  labs(fill = "Outcome")+ 
  scale_fill_manual(values=c("grey", "firebrick1", "mediumpurple", "dodgerblue"))
```


#### Taxa 
```{r NEW Actions for types of species, echo=FALSE, warning=FALSE}

taxa2 <- outcomes

## Filling in missing data 
taxa2[which(is.na(taxa2$vert_vs_invert)),12] <- c("I")
taxa2[which(is.na(taxa2$species_group)),13] <- "Insects"   

taxa2 <- taxa2 %>% select(scientific_name, common_name, vert_vs_invert:species_group, habitat_modification:demographic_stochasticity,  preempt:react, public:private)



taxa2 <- taxa2 %>%  mutate(plant = case_when(grepl("P", vert_vs_invert, ignore.case = TRUE) ~ 1)) %>% # Finding all cases where Plant and create column of ones that can use to multiply as follows... 
 mutate(plant_preempt_yes = plant*preempt) %>% ## any cases will have 1
  mutate(plant_preempt_no = case_when(plant_preempt_yes < 1 ~ 1  )) ## where ever there is no 1, create a new column and put a one 

### now going to apply the same thing for verts and inverts 

taxa2 <- taxa2 %>%  mutate(vert = case_when(grepl("V", vert_vs_invert, ignore.case = TRUE) ~ 1)) %>% # Finding all cases where Plant and create column of ones that can use to multiply as follows... 
 mutate(vert_preempt_yes = vert*preempt) %>% ## any cases will have 1
  mutate(vert_preempt_no = case_when(vert_preempt_yes < 1 ~ 1  )) 

taxa2 <- taxa2 %>%  mutate(invert = case_when(grepl("I", vert_vs_invert, ignore.case = TRUE) ~ 1)) %>% # Finding all cases where Plant and create column of ones that can use to multiply as follows... 
 mutate(invert_preempt_yes = invert*preempt) %>% ## any cases will have 1
  mutate(invert_preempt_no = case_when(invert_preempt_yes < 1 ~ 1  )) 

### Now I need to do the same thing for the other action (responsive)

taxa2 <- taxa2 %>% 
 mutate(plant_react_yes = plant*react) %>% ## any cases will have 1
  mutate(plant_react_no = case_when(plant_react_yes < 1 ~ 1  )) %>% 
  
  mutate(vert_react_yes = vert*react) %>% ## any cases will have 1
  mutate(vert_react_no = case_when(vert_react_yes < 1 ~ 1  )) %>% 
  
  mutate(invert_react_yes = invert*react) %>% ## any cases will have 1
  mutate(invert_react_no = case_when(invert_react_yes < 1 ~ 1  )) 



## taxa: actions 

taxa_actions <- taxa2
taxa_actions <- taxa_actions %>% select(plant_preempt_yes, plant_preempt_no, plant_react_yes, plant_react_no, vert_preempt_yes, vert_preempt_no, vert_react_yes, vert_react_no, invert_preempt_yes, invert_preempt_no , invert_react_yes, invert_react_no)

taxa_actions <- colSums(taxa_actions[,c(1:12)], na.rm = T) 
taxa_actions <- as.data.frame(taxa_actions) %>% rownames_to_column()

taxa_actions1 <- taxa_actions %>% separate(rowname, c("one", "two", "three"), "_")  ## seperating into three different columns based on "_"

taxa_actions2 <- taxa_actions1 %>%  pivot_wider(names_from = three, values_from = taxa_actions) ## transforming dataset so have "Yes" and "No" as seperate columns to be set up in same way as Becky's dataset 


test_taxa_actions <- taxa_actions2 %>% select(yes, no) # Have a zero in dataset
test <- chisq.test(test_taxa_actions)
test


#fish <- pairwise_fisher_test(test_taxa_actions, workspace = 2e8, p.adjust.method = "bonferroni")
#fish

taxa_plant <- taxa_actions2 %>% filter(one == "plant") %>% select(yes, no)
fish_taxa_plant <- pairwise_fisher_test(taxa_plant, p.adjust.method = "bonferroni")
fish_taxa_plant <- fisher_test(taxa_plant)

taxa_vert <- taxa_actions2 %>% filter(one == "vert") %>% select(yes, no)
fish_taxa_vert <- pairwise_fisher_test(taxa_vert, p.adjust.method = "bonferroni")
fish_taxa_vert <- fisher_test(taxa_vert)

taxa_preempt <- taxa_actions2 %>% filter(two == "preempt") %>% select(yes, no)
fish_taxa_preempt <- pairwise_fisher_test(taxa_preempt, p.adjust.method = "bonferroni")
fish_taxa_preempt <- fisher_test(taxa_preempt)


taxa_react <- taxa_actions2 %>% filter(two == "react") %>% select(yes, no)
fish_taxa_react <- pairwise_fisher_test(taxa_react, p.adjust.method = "bonferroni")
fish_taxa_react <- fisher_test(taxa_react)




ggplot(taxa_actions1) + aes(x=two, y=taxa_actions, fill = (three)) +
  geom_bar(stat="identity", position = "stack") + 
  facet_wrap(~one) +
  ggtitle("Actions for types of species") + 
  scale_y_continuous(name = "count")+
  labs(fill = "Yes or No")+ 
  theme(panel.margin = grid:: unit(-1.25, "lines"))
  
  
#ggplot(taxa_actions1) + aes(x=one, y=taxa_actions, fill = (three)) +
#  geom_bar(stat="identity", position = "dodge", color = "black") +
#  labs(fill = "Yes or No")

```






```{r OLD Land Type for types of species, echo=FALSE,  warning=FALSE, eval=FALSE}
### ### ### Taxa -- Land 
  ### 	all species, plant species, animal species (outcome: land)

taxa_land <- taxa %>% select(scientific_name, landresults, vert_vs_invert )

plants <- taxa_land %>% filter(vert_vs_invert == "P") %>% ## Select which species type to subset 
pivot_wider(names_from = landresults, values_from = vert_vs_invert) %>%  ## may action types col names
  as.data.frame() %>%  # turn to dataframe
  replace(!is.na(.), 1)  # convert all values to 1s so can col sum below 
plants[,c(1:5)] <- sapply(plants[ ,c(1:5)], as.numeric)
plants <- colSums(plants[,c(2:5)], na.rm = T)
plants <- as.data.frame(plants) %>% rownames_to_column()

invert <- taxa_land %>% filter(vert_vs_invert == "I") %>% ## Select which species type to subset 
pivot_wider(names_from = landresults, values_from = vert_vs_invert) %>%  ## may action types col names
  as.data.frame() %>%  # turn to dataframe
  replace(!is.na(.), 1)  # convert all values to 1s so can col sum below 
invert[,c(1:4)] <- sapply(invert[ ,c(1:4)], as.numeric)
invert <- colSums(invert[,c(2:4)], na.rm = T) 
invert <- as.data.frame(invert) %>% rownames_to_column()
  #rownames_to_column() 

vert <- taxa_land %>% filter(vert_vs_invert == "V") %>% ## Select which species type to subset 
pivot_wider(names_from = landresults, values_from = vert_vs_invert) %>%  ## may action types col names
  as.data.frame() %>%  # turn to dataframe
  replace(!is.na(.), 1)  # convert all values to 1s so can col sum below 
vert[,c(1:5)] <- sapply(vert[ ,c(1:5)], as.numeric)
vert <- colSums(vert[,c(2:5)], na.rm = T) 
vert <- as.data.frame(vert) %>% rownames_to_column()

species_actions <- full_join(plants, vert, by = "rowname")
species_actions <- full_join(species_actions, invert, by = "rowname")
species_actions <- species_actions %>% rowwise() %>%  mutate("all_sp" = sum(plants,vert, invert, na.rm = T))
  
### make bar graph 

sactions <- species_actions
rownames(sactions) <- c("public_only", "NA", "both_public_private", "private_only"  )
sactions <- as.data.frame(sactions)
#s <- s[,-c(1)]
sactions_melt <- sactions %>% melt()

ggplot(sactions_melt) + aes(x=variable, y=value, fill = factor(rowname, levels=c("NA", "private_only", "both_public_private", "public_only"))) +
  geom_bar(stat="identity") + 
  scale_x_discrete(name ="species") + 
  ggtitle("Land Type for types of species") + 
  scale_y_continuous(name = "count")+ 
  labs(fill = "Land")+ 
  scale_fill_manual(values=c("grey", "firebrick1", "mediumpurple", "dodgerblue"))


```


```{r NEW Land Type for types of speciess, echo=FALSE, warning=FALSE}

taxa2 <- outcomes

## Filling in missing data 
taxa2[which(is.na(taxa2$vert_vs_invert)),12] <- c("I")
taxa2[which(is.na(taxa2$species_group)),13] <- "Insects"   

taxa2 <- taxa2 %>% select(scientific_name, common_name, vert_vs_invert:species_group, habitat_modification:demographic_stochasticity,  preempt:react, public:private)



taxa2 <- taxa2 %>%  mutate(plant = case_when(grepl("P", vert_vs_invert, ignore.case = TRUE) ~ 1)) %>% # Finding all cases where Plant and create column of ones that can use to multiply as follows... 
 mutate(plant_public_yes = plant*public) %>% ## any cases will have 1
  mutate(plant_public_no = case_when(plant_public_yes < 1 ~ 1  )) ## where ever there is no 1, create a new column and put a one 

### now going to apply the same thing for verts and inverts 

taxa2 <- taxa2 %>%  mutate(vert = case_when(grepl("V", vert_vs_invert, ignore.case = TRUE) ~ 1)) %>% # Finding all cases where Plant and create column of ones that can use to multiply as follows... 
 mutate(vert_public_yes = vert*public) %>% ## any cases will have 1
  mutate(vert_public_no = case_when(vert_public_yes < 1 ~ 1  )) 

taxa2 <- taxa2 %>%  mutate(invert = case_when(grepl("I", vert_vs_invert, ignore.case = TRUE) ~ 1)) %>% # Finding all cases where Plant and create column of ones that can use to multiply as follows... 
 mutate(invert_public_yes = invert*public) %>% ## any cases will have 1
  mutate(invert_public_no = case_when(invert_public_yes < 1 ~ 1  )) 

### Now I need to do the same thing for the other land type (private)

taxa2 <- taxa2 %>% 
 mutate(plant_private_yes = plant*private) %>% ## any cases will have 1
  mutate(plant_private_no = case_when(plant_private_yes < 1 ~ 1  )) %>% 
  
  mutate(vert_private_yes = vert*private) %>% ## any cases will have 1
  mutate(vert_private_no = case_when(vert_private_yes < 1 ~ 1  )) %>% 
  
  mutate(invert_private_yes = invert*private) %>% ## any cases will have 1
  mutate(invert_private_no = case_when(invert_private_yes < 1 ~ 1  )) 



## taxa: actions 

taxa_land <- taxa2
taxa_land <- taxa_land %>% select(plant_public_yes, plant_public_no, plant_private_yes, plant_private_no, vert_public_yes, vert_public_no, vert_private_yes, vert_private_no, invert_public_yes, invert_public_no , invert_private_yes, invert_private_no)

taxa_land <- colSums(taxa_land[,c(1:12)], na.rm = T) 
taxa_land <- as.data.frame(taxa_land) %>% rownames_to_column()

taxa_land1 <- taxa_land %>% separate(rowname, c("one", "two", "three"), "_")  ## seperating into three different columns based on "_"

taxa_land2 <- taxa_land1 %>%  pivot_wider(names_from = three, values_from = taxa_land) ## transforming dataset so have "Yes" and "No" as seperate columns to be set up in same way as Becky's dataset 


test_taxa_land <- taxa_land2 %>% select(yes, no) # Have a zero in dataset
test <- chisq.test(test_taxa_land)
test


#fish <- row_wise_fisher_test(test_taxa_land, workspace = 2e8, p.adjust.method = "bonferroni")
#fish



taxa_plant <- taxa_land2 %>% filter(one == "plant") %>% select(yes, no)
fish_taxa_plant <- pairwise_fisher_test(taxa_plant, p.adjust.method = "bonferroni")
fish_taxa_plant <- fisher_test(taxa_plant)

taxa_vert <- taxa_land2 %>% filter(one == "vert") %>% select(yes, no)
fish_taxa_vert <- pairwise_fisher_test(taxa_vert, p.adjust.method = "bonferroni")
fish_taxa_vert <- fisher_test(taxa_vert)

taxa_public <- taxa_land2 %>% filter(two == "public") %>% select(yes, no)
fish_taxa_public <- pairwise_fisher_test(taxa_public, p.adjust.method = "bonferroni")
#fish_taxa_public <- fisher_test(taxa_public)


taxa_private <- taxa_land2 %>% filter(two == "private") %>% select(yes, no)
fish_taxa_private <- pairwise_fisher_test(taxa_private, p.adjust.method = "bonferroni")
#fish_taxa_private <- fisher_test(taxa_private)


ggplot(taxa_land1) + aes(x=two, y=taxa_land, fill = (three)) +
  geom_bar(stat="identity", position = "stack") + 
  facet_wrap(~one) +
  ggtitle("Land for types of species") + 
  scale_y_continuous(name = "count")+
  labs(fill = "Yes or No")+ 
  theme(panel.margin = grid:: unit(-1.25, "lines"))
  
```



```{r OLD land actions for a species, echo=FALSE,  warning=FALSE, eval=FALSE}

### ### ### ### ### ### ### ### ### ### ### ### ### Land

### ### ### ### ###  Land -- Preempt 
  ### public land actions for a species, private land actions for a species (outcome: preempt)

land_preempt <- outcomes
land_preempt <- land_preempt %>% select(scientific_name, actionresults, landresults)

land_preempt$number <- rownames(land_preempt)


land_preempt_trial <- land_preempt %>% pivot_wider(values_from = number, names_from = landresults)

land_preempt_trial[,c(3:6)] <- sapply(land_preempt_trial[ ,c(3:6)], as.numeric)

land_preempt_trial <- land_preempt_trial %>% mutate_if(is.numeric, ~1 * (. > 0)) #changed all values back to ones and zeros

land_preempt_trial <- as.data.table(land_preempt_trial)
names(land_preempt_trial) <- c( "scientific_name"   ,  "actionresults"   ,    "public_only"    ,     "NotApp"     ,       "private_only"   ,     "both_public_private" )

land_preempt_trial[which(is.na(land_preempt_trial$actionresults)),2] <- "NApp" 

#Want to use equivalent of group by and then colsum (tidyr version didn't work but the datatable method does)
count <- land_preempt_trial[,list(public_only=sum(public_only, na.rm = T), NotApp=sum(NotApp, na.rm = T), private_only = sum(private_only, na.rm = T), both_public_private = sum(both_public_private, na.rm = T)), by='actionresults']

## Couldn't get this to work
#land_preempt_trial <- land_preempt_trial %>% select(-scientific_name) %>% group_by(actionresults) %>% 
#summarize_at(var(react_only, NApp, preempt_only, both_react_preempt), fun = colSums)
#  summarise_if(is.integer, sum, na.rm = T)

act_land <- count %>% melt()

ggplot(act_land) + aes(x=variable, y=value, fill = factor(actionresults, levels=c("NApp", "react_only", "both_react_preempt", "preempt_only"))) +
  geom_bar(stat="identity") + 
  scale_x_discrete(name ="Land Owner Type") + 
  ggtitle("land actions for a species (outcome: preempt") + 
  scale_y_continuous(name = "count")+
    labs(fill = "Outcome")+ 
    scale_fill_manual(values=c("grey", "firebrick1", "mediumpurple", "dodgerblue"))


```

#### Land actions 
```{r NEW land actions, echo=FALSE, warning=FALSE}

landactions <- outcomes

landactions <- landactions %>% select(scientific_name, common_name,  preempt:react, public:private)

landactions[which(landactions$preempt == 0),3] <- NA
landactions[which(landactions$react == 0),4] <- NA

landactions <- landactions %>%  
 mutate(preempt_public_yes = preempt*public) %>% ## any cases will have 1
  mutate(preempt_public_no = case_when(preempt_public_yes < 1 ~ 1  )) %>% 
 mutate(preempt_private_yes = preempt*private) %>% ## any cases will have 1
  mutate(preempt_private_no = case_when(preempt_private_yes < 1 ~ 1  )) %>%

  mutate(react_public_yes = react*public) %>% ## any cases will have 1
  mutate(react_public_no = case_when(react_public_yes < 1 ~ 1  )) %>% 
 mutate(react_private_yes = react*private) %>% ## any cases will have 1
  mutate(react_private_no = case_when(react_private_yes < 1 ~ 1  )) 
 
 


landactionsa <- landactions
landactionsa <- landactionsa %>% select(-scientific_name:-private)

landactionsa <- colSums(landactionsa[,c(1:8)], na.rm = T) 
landactionsa <- as.data.frame(landactionsa) %>% rownames_to_column()

landactions1 <- landactionsa %>% separate(rowname, c("one", "two", "three"), "_")  ## seperating into three different columns based on "_"

landactions2 <- landactions1 %>%  pivot_wider(names_from = three, values_from = landactionsa) ## transforming dataset so have "Yes" and "No" as seperate columns to be set up in same way as Becky's dataset 


test_landactions <- landactions2 %>% select(yes, no) # Have a zero in dataset
test <- chisq.test(test_landactions)
test

#fish <- row_wise_fisher_test(test_landactions, workspace = 2e8, p.adjust.method = "bonferroni")
#fish


landactions_preempt <- landactions2 %>% filter(one == "preempt") %>% select(yes, no)
fish_landactions_preempt <- pairwise_fisher_test(landactions_preempt, p.adjust.method = "bonferroni")
fish_landactions_preempt <- fisher_test(landactions_preempt)

landactions_react <- landactions2 %>% filter(one == "react") %>% select(yes, no)
fish_landactions_react <- pairwise_fisher_test(landactions_react, p.adjust.method = "bonferroni")
fish_landactions_react <- fisher_test(landactions_react)



ggplot(landactions1) + aes(x=two, y=landactionsa, fill = (three)) +
  geom_bar(stat="identity", position = "stack") + 
  facet_wrap(~one) +
  ggtitle("Land for types of actions") + 
  scale_y_continuous(name = "count")+
  labs(fill = "Yes or No")+ 
  theme(panel.margin = grid:: unit(-1.25, "lines"))
  
```


```{r NEW INVERSE land actions, echo=FALSE, warning=FALSE}

landactions <- outcomes

landactions <- landactions %>% select(scientific_name, common_name,  preempt:react, public:private)

landactions[which(landactions$public == 0),5] <- NA
landactions[which(landactions$private == 0),6] <- NA

landactions <- landactions %>%  
 mutate(preempt_public_yes = preempt*public) %>% ## any cases will have 1
  mutate(preempt_public_no = case_when(preempt_public_yes < 1 ~ 1  )) %>% 
 mutate(preempt_private_yes = preempt*private) %>% ## any cases will have 1
  mutate(preempt_private_no = case_when(preempt_private_yes < 1 ~ 1  )) %>%

  mutate(react_public_yes = react*public) %>% ## any cases will have 1
  mutate(react_public_no = case_when(react_public_yes < 1 ~ 1  )) %>% 
 mutate(react_private_yes = react*private) %>% ## any cases will have 1
  mutate(react_private_no = case_when(react_private_yes < 1 ~ 1  )) 
 
 


landactionsa <- landactions
landactionsa <- landactionsa %>% select(-scientific_name:-private)

landactionsa <- colSums(landactionsa[,c(1:8)], na.rm = T) 
landactionsa <- as.data.frame(landactionsa) %>% rownames_to_column()

landactions1 <- landactionsa %>% separate(rowname, c("one", "two", "three"), "_")  ## seperating into three different columns based on "_"

landactions2 <- landactions1 %>%  pivot_wider(names_from = three, values_from = landactionsa) ## transforming dataset so have "Yes" and "No" as seperate columns to be set up in same way as Becky's dataset 


test_landactions <- landactions2 %>% select(yes, no) # Have a zero in dataset
test <- chisq.test(test_landactions)
test



fish <- row_wise_fisher_test(test_landactions, workspace = 2e8, p.adjust.method = "bonferroni")
fish

ggplot(landactions1) + aes(x=one, y=landactionsa, fill = (three)) +
  geom_bar(stat="identity", position = "stack") + 
  facet_wrap(~two) +
  ggtitle("Land for types of actions") + 
  scale_y_continuous(name = "count")+
  labs(fill = "Yes or No")+ 
  theme(panel.margin = grid:: unit(-1.25, "lines"))
  
```


```{r OLD chunk, echo=FALSE, include=FALSE, eval=FALSE}

### ### ### ### ### Range size -- Preempt  
  ### restricted versus wide-ranging species? (outcome: preempt)
## Note - this seems to really depend on what you set the area cutoff to

hist(outcomes$range_area, breaks = 40)
## let's do 2 categories of small v large range (split point = 2.0e + 10)

range <- outcomes
range <- range %>% select(scientific_name, range_area, actionresults)
range <- range %>% mutate(size = range_area < (.5*10^10))
#Want to use equivalent of group by and then colsum (tidyr version didn't work but the datatable method does)

range$number <- 1
range <- range %>% pivot_wider(values_from = number, names_from = size)
names(range) <- c("scientific_name" ,"range_area"    ,  "actionresults"  , "Big", "Small"        ,    "NotAp" )
range <- as.data.table(range)
count_range <- range[,list(Big=sum(Big, na.rm = T), Small=sum(Small, na.rm = T), NotAp = sum(NotAp, na.rm = T)), by='actionresults']

count_range <- count_range %>% melt()

ggplot(count_range) + aes(x=variable, y=value, fill = actionresults) +
  geom_bar(stat="identity") + 
  scale_x_discrete(name ="Range Size") + 
  ggtitle("Restrictied vs wide-ranging species (outcome: preempt)") + 
  scale_y_continuous(name = "count") +
  labs(fill = "Outcome")


## Try again later 

```


```{r OLD threat type, echo=FALSE, eval=FALSE}
### ### ### ### ### Range size -- Preempt 
  ### 	presence of each threat type (outcome: preempt)

threat_type <- outcomes
threat_type <- threat_type %>% select(scientific_name, habitat_modification:total_threats, actionresults)

# note - going to do this independently (so for each threat type not by species.. slightly different than other ones)

habitat <- threat_type %>% filter(habitat_modification == 1) %>% ## Select which species type to subset 
pivot_wider(names_from = actionresults, values_from = habitat_modification) %>%  ## may action types col names
  as.data.frame() # turn to dataframe
habitat[,c(8:11)] <- sapply(habitat[ ,c(8:11)], as.numeric)
habitat <- colSums(habitat[,c(8:11)], na.rm = T) 
habitat <- as.data.frame(habitat) %>% rownames_to_column()

#only one instance for this one
overut <- threat_type %>% filter(overutilization == 1) %>% ## Select which species type to subset 
pivot_wider(names_from = actionresults, values_from = overutilization) %>%  ## may action types col names
  as.data.frame() # turn to dataframe
overut[,c(8)] <- sapply(overut[ ,c(8)], as.numeric)
overut <- colSums(overut[,c(7:8)], na.rm = T) 
overut <- as.data.frame(overut) %>% rownames_to_column()

polu <- threat_type %>% filter(pollution == 1) %>% ## Select which species type to subset 
pivot_wider(names_from = actionresults, values_from = pollution) %>%  ## may action types col names
  as.data.frame() # turn to dataframe
polu[,c(7:8)] <- sapply(polu[ ,c(7:8)], as.numeric)
polu <- colSums(polu[,c(7:8)], na.rm = T) 
polu <- as.data.frame(polu) %>% rownames_to_column()

spsp <- threat_type %>% filter(species_species_interactions == 1) %>% ## Select which species type to subset 
pivot_wider(names_from = actionresults, values_from = species_species_interactions) %>%  ## may action types col names
  as.data.frame() # turn to dataframe
spsp[,c(8:11)] <- sapply(spsp[ ,c(8:11)], as.numeric)
spsp <- colSums(spsp[,c(8:11)], na.rm = T) 
spsp <- as.data.frame(spsp) %>% rownames_to_column()

env_st <- threat_type %>% filter(env_stochasticity == 1) %>% ## Select which species type to subset 
pivot_wider(names_from = actionresults, values_from = env_stochasticity) %>%  ## may action types col names
  as.data.frame() # turn to dataframe
env_st[,c(8:10)] <- sapply(env_st[ ,c(8:10)], as.numeric)
env_st <- colSums(env_st[,c(8:10)], na.rm = T) 
env_st <- as.data.frame(env_st) %>% rownames_to_column()

demo_st <- threat_type %>% filter(demographic_stochasticity == 1) %>% ## Select which species type to subset 
pivot_wider(names_from = actionresults, values_from = demographic_stochasticity) %>%  ## may action types col names
  as.data.frame() # turn to dataframe
demo_st[,c(8:9)] <- sapply(demo_st[ ,c(8:9)], as.numeric)
demo_st <- colSums(demo_st[,c(8:9)], na.rm = T) 
demo_st <- as.data.frame(demo_st) %>% rownames_to_column()

threats_actions <- full_join(habitat, overut) %>% full_join(spsp) %>% full_join(env_st) %>% full_join(demo_st)

threats_actions <- threats_actions[-which(is.na(threats_actions$habitat)),]

threats_actions <- threats_actions %>% melt()

ggplot(threats_actions) + aes(x=variable, y=value, fill = factor(rowname, levels=c("NA", "react_only", "both_react_preempt", "preempt_only"))) +
  geom_bar(stat="identity") + 
  scale_x_discrete(name ="Type of Threat") + 
  ggtitle("presence of each threat type (outcome: preempt)") + 
  scale_y_continuous(name = "count") +
  labs(fill = "Outcome")+ 
  scale_fill_manual(values=c("grey", "firebrick1", "mediumpurple", "dodgerblue"))

### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### ### 
    
  

```


####threat types 
Note - missing three species because don't have data
```{r NEW threat types, echo=FALSE, warning=FALSE}

types <- outcomes

types <- types %>% select(scientific_name, common_name, vert_vs_invert:species_group, habitat_modification:demographic_stochasticity,  preempt:react, public:private)

## changing 0s in threat types to NA then following code will work (issue was that want to subset 1s for each threat type, but can't get inverse without including 0s for threat type so turning 0s to NAs)

types[which(types$habitat_modification == 0),5] <- NA
types[which(types$overutilization == 0),6] <- NA
types[which(types$pollution == 0),7] <- NA
types[which(types$species_species_interactions == 0),8] <- NA
types[which(types$env_stochasticity == 0),9] <- NA
types[which(types$demographic_stochasticity == 0),10] <- NA


#going through and creating two new cols with preempt, threat and y/n
types <- types %>%  mutate(hab_preempt_yes = habitat_modification*preempt) %>% ## any cases will have 1
  mutate(hab_preempt_no = case_when(hab_preempt_yes < 1 ~ 1  )) %>% 
    mutate(overut_preempt_yes = overutilization*preempt) %>% ## 
  mutate(overut_preempt_no = case_when(overut_preempt_yes < 1 ~ 1  )) %>% 
    mutate(poll_preempt_yes = pollution*preempt) %>% ## 
  mutate(poll_preempt_no = case_when(poll_preempt_yes < 1 ~ 1  )) %>% 
    mutate(spsp_preempt_yes = species_species_interactions*preempt) %>% ## 
  mutate(spsp_preempt_no = case_when(spsp_preempt_yes < 1 ~ 1  )) %>% 
      mutate(envst_preempt_yes = env_stochasticity*preempt) %>% ## 
  mutate(envst_preempt_no = case_when(envst_preempt_yes < 1 ~ 1  )) %>% 
     mutate(demst_preempt_yes = demographic_stochasticity*preempt) %>% ## 
  mutate(demst_preempt_no = case_when(demst_preempt_yes < 1 ~ 1  )) %>%  ##### now switching to protect
  
  mutate(hab_react_yes = habitat_modification*react) %>% ## any cases will have 1
  mutate(hab_react_no = case_when(hab_react_yes < 1 ~ 1  )) %>% 
    mutate(overut_react_yes = overutilization*react) %>% ## 
  mutate(overut_react_no = case_when(overut_react_yes < 1 ~ 1  )) %>% 
    mutate(poll_react_yes = pollution*react) %>% ## 
  mutate(poll_react_no = case_when(poll_react_yes < 1 ~ 1  )) %>% 
    mutate(spsp_react_yes = species_species_interactions*react) %>% ## 
  mutate(spsp_react_no = case_when(spsp_react_yes < 1 ~ 1  )) %>% 
      mutate(envst_react_yes = env_stochasticity*react) %>% ## 
  mutate(envst_react_no = case_when(envst_react_yes < 1 ~ 1  )) %>% 
     mutate(demst_react_yes = demographic_stochasticity*react) %>% ## 
  mutate(demst_react_no = case_when(demst_react_yes < 1 ~ 1  ))
  
  
  ## Scrap work.. 
## #*******## Need to fiugre out how to mutate 5 columns at once ... don't just want one new column.. we want 5
##mutate_at(.funs = (funs(. *preempt)), .cols = vars(habitat_modification:demographic_stochasticity), names = "{col}_preempt_yes") ## this changes the threat columns so now have to rename all 
  



## taxa: actions 

threat_actions <- types %>% select(-scientific_name:-private)

threat_actions <- colSums(threat_actions[,c(1:24)], na.rm = T) 
threat_actions <- as.data.frame(threat_actions) %>% rownames_to_column()

threat_actions1 <- threat_actions %>% separate(rowname, c("one", "two", "three"), "_")  ## seperating into three different columns based on "_"

threat_actions2 <- threat_actions1 %>%  pivot_wider(names_from = three, values_from = threat_actions) ## transforming dataset so have "Yes" and "No" as seperate columns to be set up in same way as Becky's dataset 


test_threat_actions <- threat_actions2 %>% select(yes, no) # Have a zero in dataset
test <- chisq.test(test_threat_actions)
test



#fish <- row_wise_fisher_test(test_threat_actions, workspace = 2e8, p.adjust.method = "bonferroni")
#fish

threat_preempt <- threat_actions2 %>% filter(two == "preempt") %>% select(yes, no)
fish_threat_preempt <- pairwise_fisher_test(threat_preempt, p.adjust.method = "bonferroni")
fish_threat_preempt <- fisher_test(threat_preempt)

threat_react <- threat_actions2 %>% filter(two == "react") %>% select(yes, no)
fish_threat_react <- pairwise_fisher_test(threat_react, p.adjust.method = "bonferroni")
fish_threat_react <- fisher_test(threat_react)



threat_hab <- threat_actions2 %>% filter(one == "hab") %>% select(yes, no)
fish_threat_hab <- pairwise_fisher_test(threat_hab, p.adjust.method = "bonferroni")
fish_threat_hab <- fisher_test(threat_hab)

threat_overut <- threat_actions2 %>% filter(one == "overut") %>% select(yes, no)
fish_threat_overut <- pairwise_fisher_test(threat_overut, p.adjust.method = "bonferroni")
fish_threat_overut <- fisher_test(threat_overut)

threat_poll <- threat_actions2 %>% filter(one == "poll") %>% select(yes, no)
fish_threat_poll <- pairwise_fisher_test(threat_poll, p.adjust.method = "bonferroni")
fish_threat_poll <- fisher_test(threat_poll)

#### This is the only one sig 
threat_spsp <- threat_actions2 %>% filter(one == "spsp") %>% select(yes, no)
fish_threat_spsp <- pairwise_fisher_test(threat_spsp, p.adjust.method = "bonferroni")
fish_threat_spsp <- fisher_test(threat_spsp)

threat_envst <- threat_actions2 %>% filter(one == "envst") %>% select(yes, no)
fish_threat_envst <- pairwise_fisher_test(threat_envst, p.adjust.method = "bonferroni")
fish_threat_envst <- fisher_test(threat_envst)

threat_demst <- threat_actions2 %>% filter(one == "demst") %>% select(yes, no)
fish_threat_demst <- pairwise_fisher_test(threat_demst, p.adjust.method = "bonferroni")
fish_threat_demst <- fisher_test(threat_demst)



ggplot(threat_actions1) + aes(x=two, y=threat_actions, fill = (three)) +
  geom_bar(stat="identity", position = "stack") + 
  facet_wrap(~one) +
  ggtitle("Actions for types of threats") + 
  scale_y_continuous(name = "count")+
  labs(fill = "Yes or No")+ 
  theme(panel.margin = grid:: unit(-1.25, "lines"))
  
  
#ggplot(taxa_actions1) + aes(x=one, y=taxa_actions, fill = (three)) +
#  geom_bar(stat="identity", position = "dodge", color = "black") +
#  labs(fill = "Yes or No")

```





Chi squares 
```{r, echo=FALSE, eval=FALSE}
# assumption: 5 or more in at least 80% of the cells, and no cell should have an expected of less than one (3).


### ### ###	Differences in frequency of proactive and protective measures on public versus private lands (Chi-square)

differences <- outcomes
differences <- as.data.frame(differences)
differences[,c(3:10)] <- sapply(differences[ ,c(3:10)], as.numeric)
count_diff <- colSums(differences[,c(3:10)], na.rm = T)
count_diff <- as.data.frame(count_diff)

## manually entering into table 
#### note numbers have changes
diff_tb <- data.frame('preempt' = c(15,21,22), 'respon' = c(2,14,17), 'unc' = c(7,13,0))
rownames(diff_tb) <- c("private", "public", "unc")

kable(diff_tb)

chsq <- chisq.test(diff_tb)

#chsq$residuals

#corrplot(chsq$residuals, is.cor = FALSE)

contrib <- 100*chsq$residuals^2/chsq$statistic
#round(contrib, 3)
#corrplot(contrib, is.cor = FALSE)


### ### ###	Removing UNC from - Differences in frequency of proactive and protective measures on public versus private lands (Chi-square) 

diff_tb <- data.frame('preempt' = c(15,21), 'respon' = c(2,14))
rownames(diff_tb) <- c("private", "public")

chsq <- chisq.test(diff_tb)
#chsq$residuals
#corrplot(chsq$residuals, is.cor = FALSE)
contrib <- 100*chsq$residuals^2/chsq$statistic
#round(contrib, 3)
#corrplot(contrib, is.cor = FALSE)


### I think I need to use fisher's exact here because 1 out of 4 values is less than 5... 

fish <- fisher.test(diff_tb)
fish



### ### ###		Difference in protective versus proactive for plants versus animals

act_taxa <- s
act_taxa <- act_taxa %>% select(-rowname)

#add vert and invert to see if can get values up for chi square
act_taxa <- act_taxa %>% mutate(allvert = vert + invert)
act_taxa <- act_taxa %>% select(-vert, -invert)

## *** issue here - values are still too low 

### ### ###		Difference in public versus private lands actions for plant versus animal

land_taxa <- sactions
land_taxa <- land_taxa %>% select(-rowname)
rname <- rownames(land_taxa)

#add vert and invert to see if can get values up for chi square
land_taxa <- land_taxa %>% mutate(allvert = vert + invert)
land_taxa <- land_taxa %>% select(-vert, -invert)
rownames(land_taxa) <- rname

## *** issue here - values are still too low 


```




## 3.	Who are the organizations/players involved in conserving the conservation of the species (eg in an agreement of effort)? 

#### 3 - Data wrangling 

```{r, include = FALSE, echo = FALSE}

partners <- sub_initiatves_partners

# remove rows where there is an NA for partner
##partners <- partners[-which(is.na(partners$RowSpecInfo)),] ## this might be redudent and cause issues later but for now needed (delete later if run into NA issues)

#need to remove multi partner strings
partners <- partners[-which(partners$Type_of_Org == "multi"),]

#remove black "NA" partners
partners <- partners[-which(is.na(partners$Partners)),]

# also want to do a check of spelling to see if sort partner names alphabetically, do any different verions show up (might not even be user error - some entities had name changes that were flagged in FR)
# check complete - ran: 
          #mod_partner_count <- sub_partners %>% group_by(scientific_name) %>%  distinct(Partners)
# and looks good 


## count number of partners for each species
## make two versions 
  # one normal
  # the other where remove text after - (eg BLM-Suprise Feild office would be BLM)

normal_partner_count <- partners %>% group_by(scientific_name) %>% 
  distinct(Partners) %>%  summarise(n()) 
#nothing removed or changed 

names(normal_partner_count) <- c("scientific_name", "normal_count" )

#remove flattailed outlier 

no_lizard <- normal_partner_count

no_lizard <- no_lizard %>% filter(!grepl("Phrynosoma", scientific_name))
names(no_lizard) <- c("scientific_name", "no_liz" )

#remove offices
sub_partners <- partners
sub_partners$Partners <- gsub("(.*)-.*", "\\1", sub_partners$Partners) ## Altered text from https://stackoverflow.com/questions/25307899/r-remove-anything-after-comma-from-columnn 

mod_partner_count <- sub_partners %>% group_by(scientific_name) %>% 
  distinct(Partners) %>%  summarise(n()) 

names(mod_partner_count) <- c("scientific_name", "no_offices" )

### addressing issue that Flattailed Horned lizard has so many partners - 
## after combine Federal agency offices, remove all remaining partners with "district" (otherwise will remove federal district offices if do so before - one work around might be to only remove district for this partner) issue is that the partner has 23 partners that are a subsection of county and getting repeated multiple times 

no_district <- sub_partners %>% 
  mutate(district = case_when(grepl("district", Partners, ignore.case = TRUE) ~ 1)) # Finding all cases of district and replacing with NA

#remove black the now "NA" district partners
no_district_part <- no_district[-which(no_district$district == 1),]

no_district_part_count <- no_district_part %>% group_by(scientific_name) %>% 
  distinct(Partners) %>%  summarise(n())  #count modified number of partners here now

names(no_district_part_count) <- c("scientific_name", "no_distinct")

# note - getting a bug when use duplicate so next time try match_df from plyr 

### ### So need to decide on bins 



## No HCPs

NoHCPS <- partners

NoHCPS <- NoHCPS[-which(NoHCPS$DocCategory == "HCP"),] ## loose ~90 rows 

NoHCPS_count <- NoHCPS %>% group_by(scientific_name) %>% 
  distinct(Partners) %>%  summarise(n()) 

names(NoHCPS_count) <- c("scientific_name", "NoHCPS_count")


## Partners only in FR 

FR_only <- partners

FR_only <- FR_only[which(FR_only$Partner_Source == "FR"),]

FR_only_count <- FR_only %>% group_by(scientific_name) %>% 
  distinct(Partners) %>%  summarise(n()) 

names(FR_only_count) <- c("scientific_name", "FR_only_count")

```


o	Summary stats… histograms/bar charts… (perhaps stacked bar charts where color code stacks for low, medium, high confidence in having collected most of partners)?

o	To account for the uncertainty in number of partners, we put this information into bins and then “then use an ordered probit to look at how well variables predict the rough estimate of numbers of partners.” 

o	We use logit regression models to predict participation by different “types” of partners



#### Set up model 

```{r, include = FALSE, echo = FALSE}
## Add number of partners 

partners <- full_join(normal_partner_count, mod_partner_count) %>% full_join(NoHCPS_count) %>% full_join(FR_only_count)



## create logs of range area and # initatives

reg_prdctr_partners <- reg_prdctr

## Need an extra variable to try in the partners model so pulling it here
ns_threats <- tdata %>% select(common_name, scientific_name, nserve_pop_stability)

reg_prdctr_partners <- reg_prdctr_partners %>% left_join(ns_threats, by = "scientific_name")

## Then join.. 

reg_prdctr_partners <- reg_prdctr_partners %>% 
  mutate(log_rangearea = log(range_area)) 
 
## re arrange order 
reg_prdctr_partners <- reg_prdctr_partners %>% select(scientific_name:no_iniv, log_rangearea, range_area:Big_Pg_count, nserve_pop_stability)
## removing %public until have all data and
reg_prdctr_partners <- reg_prdctr_partners %>% select(-public_mang_shannons_diversity, -no_iniv)


reg_prdctr_partners <- reg_prdctr_partners %>% left_join(partners)
#note - this variable was made in a chunk below so won't be able to knit script without bringing that information forward 

reg_partners <- reg_prdctr_partners # I want to use different set of variables in models than in cormat (more modifications to follow...)

reg_partners <- reg_partners %>% select(scientific_name, common_name.x, NoHCPS_count, log_rangearea:nserve_pop_stability) %>% select(-weighted_rural)

#reg_prdctr_partners <- as.data.frame(reg_prdctr_partners)
#reg_prdctr_partners[,c(10:13)] <- sapply(reg_prdctr_partners[ ,c(10:13)], as.numeric)
#reg_prdctr_partners <- as.data.frame(reg_prdctr_partners)

#names(reg_prdctr_partners)

#reg_prdctr_partners <- reg_prdctr_partners %>% select(scientific_name:common_name , normal_count:FR_only_count, log_rangearea, range_area:wd_proposed)


#reg_prdctr_partners <- reg_prdctr_partners %>% 
 # mutate(log_normal = log(normal_count)) %>% 
  #mutate(log_HCPS = log(NoHCPS_count))%>% 
  #mutate(log_FR = log(FR_only_count))


#reg_prdctr_partners <- reg_prdctr_partners %>% select(scientific_name:common_name , -normal_count:-FR_only_count, -log_normal:-log_FR, log_HCPS, log_rangearea, range_area:wd_proposed)

```




### Base model

```{r Correlation Matrix 2, include = FALSE, echo = FALSE}
# Correlation Matrix of Predictors vs Responses ##
## modified some code from http://handlesman.blogspot.com/2011/03/matrix-plot-with-confidence-intervals.html
#Not working because of NAs in data - getting error that x is not numeric 


#set up
PredictorsOnlyPixel <- reg_partners[,c(3)]
PredictAndResponsePixel <- reg_partners[,-c(1:2)]
PredictAndResponseGrid <- reg_partners[,-c(1:2)]
  
# put histograms on the diagonal panel	
panel.hist <- function (x,...)					# define a function that says what we want to plot in the diagonal
{
  usr <- par("usr"); on.exit(par(usr))			# not sure what usr is for?
  par(usr = c(usr[1:2],0,1.5))
  h <- hist(x, plot = FALSE)
  breaks <- h$breaks; nB <- length(breaks)			# make the hist 
  y <- h$counts; y <- y/max(y)
  rect(breaks[-nB], 0, breaks[-1], y, col="grey", ...)  # defines what the histogram is going to look like
}

# put correlations on the upper panels,
panel.cor <- function(x, y, digits=2, prefix="", cex.cor, ...)
{
  usr <- par("usr"); on.exit(par(usr))
  par(usr = c(0, 1, 0, 1))
  r <- cor(x, y,use="complete.obs")				
  txt <- format(c(r, 0.123456789), digits=digits)[1]
  prefix <- "r = "
  rc <- cor.test(x,y,method = c("pearson"))				## calculate pearsons rho for upper grid
  txt <- paste(prefix,txt,sep="")
  text(0.5, 0.5, txt, cex = 1)
}

## plot a correlation matrix plot that uses the functions specified above to say what to plot where
      ## this was taken directly from website and still not plotting r values for all 
#pairs(PredictAndResponsePixel[1:6], lower.panel=panel.smooth, cex = .8, diag.panel=panel.hist, cex.labels = 1.2, font.labels=2, upper.panel=panel.cor)

##Pixel level

pairs(PredictAndResponsePixel,lower.panel = panel.smooth, diag.panel=panel.hist,upper.panel=panel.cor)



### Predictors only  -->  only have one response so not going to run this one
##pairs(PredictorsOnlyPixel,lower.panel = panel.smooth, diag.panel=panel.hist,upper.panel=panel.cor)


#test correlations to look for covariation between predictors
##cor(reg_prdctr[,-c(1:2)], use = "complete.obs") # matrix seems fine
#no na.rm in this one instead it's "use"

```

- Note: percent public variable is still in matrix but was removed from model


VIFS
```{r, include = FALSE, echo = FALSE}


vif(lm(log(NoHCPS_count) ~ range_area + plant  + total_threats,data = reg_partners))

vif(lm(log(NoHCPS_count) ~ range_area + plant + private_land_proportion + weighted_rural + total_threats,data = reg_partners))
```

```{r, include = FALSE, echo = FALSE}

reg_partners <- reg_partners[-which(is.na(reg_partners$nserve_pop_stability)),] #removes NAs (can get same number of observations)

lm1 <- lm(log(NoHCPS_count) ~ range_area + plant  + total_threats,data = reg_partners)

lm2 <- lm(log(NoHCPS_count) ~ log(range_area) + plant  + total_threats,data = reg_partners)

lm4 <- lm(log(NoHCPS_count) ~ log(range_area) + plant  + total_threats + Big_Pg_count,data = reg_partners)

lm6 <- lm(log(NoHCPS_count) ~ log(range_area) + plant  + total_threats + month_12,data = reg_partners)

lm8 <- lm(log(NoHCPS_count) ~ log(range_area) + plant  + total_threats + wd_proposed,data = reg_partners)

lm9 <- lm(log(NoHCPS_count) ~ log(range_area) + plant  + total_threats + wd_proposed + month_12,data = reg_partners)


lm10 <- lm(log(NoHCPS_count) ~  log(range_area)+ plant  + total_threats + private_land_proportion,data = reg_partners)

lm12 <- lm(log(NoHCPS_count) ~ log(range_area) + plant  + total_threats + private_land_proportion + month_12,data = reg_partners)

lm13 <- lm(log(NoHCPS_count) ~ log(range_area) + plant  + total_threats + private_land_proportion + wd_proposed,data = reg_partners)

lm14 <- lm(log(NoHCPS_count) ~ log(range_area) + plant  + total_threats + private_land_proportion + wd_proposed + month_12,data = reg_partners)

lm15 <- lm(log(NoHCPS_count) ~ log(range_area) + plant  + total_threats + private_land_proportion + Big_Pg_count,data = reg_partners)


lm11 <- lm(log(NoHCPS_count) ~ log(range_area) + plant + nserve_pop_stability,data = reg_partners)

lm16 <- lm(log(NoHCPS_count) ~ log(range_area) + plant + nserve_pop_stability + private_land_proportion, data = reg_partners)

lm17 <- lm(log(NoHCPS_count) ~ log(range_area) + plant  + total_threats + nserve_pop_stability + private_land_proportion , data = reg_partners)



#summary(lma)
#summary(lmb)
#summary(lmc)
#summary(lmd)

#AIC(lma)
#AIC(lmb)
#AIC(lmc) ## C has lowest value 
#AIC(lmd)

#check_overdispersion(lm2)



#lme <- lm(log(normal_count) ~ log(range_area) + plant + public_mang_shannons_diversity + total_threats,data = reg_prdctr_partners)

#lmf <- lm(log(no_offices) ~ log(range_area) + plant + public_mang_shannons_diversity + total_threats,data = reg_prdctr_partners)

#lmg <- lm(log(NoHCPS_count) ~ log(range_area) + plant  + total_threats +wd_proposed,data = reg_prdctr_partners)

#lmh <- lm(log(FR_only_count) ~ log(range_area) + plant + public_mang_shannons_diversity + total_threats,data = reg_prdctr_partners)

#summary(lme)
#summary(lmf)
#summary(lmg)
#summary(lmh)

#AIC(lme)
#AIC(lmf)
#AIC(lmg) ## C has lowest value 
#AIC(lmh)


## note - no changes when added FR docs


```

Adding stargazer 
- https://rpubs.com/omerorsun/week3_stargazer
```{r, include = FALSE, echo = FALSE}
stargazer(lm1, lm4, lm10, lm12, lm13, lm14, lm15,lm11, lm16, lm17, type = "html", title = "Partners_models", align = TRUE, out = "output/Partners_models_1_July_2021.html", # AIC isn't calculated for lm models so adding manually
          add.lines=list(c("AIC", round(AIC(lm1),1), round(AIC(lm4),1), round(AIC(lm10),1), round(AIC(lm12),1), round(AIC(lm13),1), round(AIC(lm14),1), round(AIC(lm15),1), round(AIC(lm11),1), round(AIC(lm16),1), round(AIC(lm17),1)  ))  )

calc <- data.frame(c("partial R2ed", calc.relimp(lm4), calc.relimp(lm10), calc.relimp(lm12), calc.relimp(lm13), calc.relimp(lm14), calc.relimp(lm15), calc.relimp(lm11), calc.relimp(lm16), calc.relimp(lm17))) 

what <- calc.relimp(lm1)

```

lmg is the R^2 contribution averaged over orderings amoung regressors
```{r}

#calc.relimp(lm10)
#calc.relimp(lm11)
#calc.relimp(lm16)
#calc.relimp(lm17)

#etasq(lm10)

rsq.partial(lm10)
rsq.partial(lm16)
rsq.partial(lm17)
```



Testing heteroskedasticity 
- Breusch-Pagan test
- https://www.r-bloggers.com/2016/01/how-to-detect-heteroscedasticity-and-rectify-it/
- https://cran.r-project.org/web/packages/olsrr/vignettes/heteroskedasticity.html
```{r}
bptest(lm10)


plot(lm10)

qqPlot(residuals(lm10))


#demo of how to resolve
food.ols <- lm(food_exp ~ income, data = food)
food$resi <- food.ols$residuals
varfunc.ols <- lm(log(resi^2) ~ log(income), data = food)
food$varfunc <- exp(varfunc.ols$fitted.values)
food.gls <- lm(food_exp ~ income, weights = 1/sqrt(varfunc), data = food)

```
While it doesn’t give us the critical value to compare the test statistic, all you need to look at is the p-value to determine whether or not you should reject the null. If the p-value is less than the level of significance (in this case if the p-value is less than α=0.05), then you reject the null hypothesis. Since 0.006579 < 0.05, we can reject the null hypothesis.

With a p-value of 0.91, we fail to reject the null hypothesis (that variance of residuals is constant) and therefore infer that ther residuals are homoscedastic. Lets check this graphically as well.




Predicting values 
- https://www.youtube.com/watch?v=ahDFXHAdZRU
- 
```{r}


## rerunning model so can have log_rangearea instead of log(range_area) --> same values but can't use predict with log(range_area) and get different set up in stargazer if run one model with log_rangearea
lm10 <- lm(log(NoHCPS_count) ~  log_rangearea+ plant  + total_threats + private_land_proportion,data = reg_partners)

#fitted model
# mod <- -7.10+0.29 * (log(range)) + -0.062 *(plant) + 0.21 (threats) + 1.58 * private_land

# Prediction: out of sample (given new observations)
# Obtain prediction for new X within range of data



## Get mean from summary stats of each predictor
summary(reg_partners$log_rangearea)
summary(reg_partners$plant)
summary(reg_partners$total_threats)
summary(reg_partners$private_land_proportion)


predict(lm10, data.frame(log_rangearea = 23.44, plant = 0.4054, total_threats = 2.324, private_land_proportion = 0.4765))

summary(lm10)

base <- predict(lm10, data.frame(log_rangearea = 23.44, plant = 0.4054, total_threats = 2.324, private_land_proportion = 0.4765))
base <- base %>% as.data.frame() %>% add_column("base")

plant_0 <- predict(lm10, data.frame(log_rangearea = 23.44, plant = 0, total_threats = 2.324, private_land_proportion = 0.4765))
plant_0 <- plant_0 %>% as.data.frame() %>% add_column("plant_0")

plant_1 <- predict(lm10, data.frame(log_rangearea = 23.44, plant = 1, total_threats = 2.324, private_land_proportion = 0.4765))
plant_1 <- plant_1 %>% as.data.frame() %>% add_column("plant_1")

plantx2 <- predict(lm10, data.frame(log_rangearea = 23.44, plant = (0.4054*2), total_threats = 2.324, private_land_proportion = 0.4765))
plantx2 <- plantx2 %>% as.data.frame() %>% add_column("plantx2")

log_rangeareax2 <- predict(lm10, data.frame(log_rangearea = (23.44*2), plant = 0.4054, total_threats = 2.324, private_land_proportion = 0.4765)) ## big change here 
log_rangeareax2 <- log_rangeareax2 %>% as.data.frame() %>% add_column("log_rangeareax2")

log_rangeareax1_2 <- predict(lm10, data.frame(log_rangearea = (23.44*.5), plant = 0.4054, total_threats = 2.324, private_land_proportion = 0.4765))
log_rangeareax1_2 <- log_rangeareax1_2 %>% as.data.frame() %>% add_column("log_rangeareax1_2")

private_land_proportionx2 <- predict(lm10, data.frame(log_rangearea = 23.44, plant = 0.4054, total_threats = 2.324, private_land_proportion = (0.4765*2)))
private_land_proportionx2 <- private_land_proportionx2 %>% as.data.frame() %>% add_column("private_land_proportionx2")

private_land_proportionx1_2 <- predict(lm10, data.frame(log_rangearea = 23.44, plant = 0.4054, total_threats = 2.324, private_land_proportion = (0.4765*.5)))
private_land_proportionx1_2 <- private_land_proportionx1_2 %>% as.data.frame() %>% add_column("private_land_proportionx1_2")

##put together dataframe

predictions <- base %>% full_join(plant_0) %>% full_join(plant_1) %>% full_join(plantx2) %>% full_join(log_rangeareax2) %>% full_join(log_rangeareax1_2) %>% full_join(private_land_proportionx2) %>% full_join(private_land_proportionx1_2)

## this is clunky 


```



## Paper 
###Summary stats

- number of unique partners working on all species 
(note - using the HCP dataset)
```{r, include = FALSE, echo = FALSE, eval=FALSE, warning=FALSE}

tryme <- NoHCPS
tryme <- tryme %>% distinct(Partners) 



summary(reg_partners$NoHCPS_count)

```







Scrap - testing ECOS csv against our list of species 

```{r, include = FALSE, echo = FALSE, eval=FALSE, warning=FALSE}

mod_species    <- initiatves_partners  

mod_species <- mod_species %>% group_by(scientific_name) %>% 
  distinct(Partners) %>%  summarise(n()) 

names(mod_species) <- c("Scientific.Name", "count")
      
ECOS <- read.csv(paste0(DataSource,"/ECOS_species-precluded-from-listing-report.csv"), stringsAsFactors = FALSE) 

                            
testing <- mod_species %>% full_join(ECOS)


### 26 species that are on our list but not on ECOS

#21 species on ECOS that are not on our list 


```


run confidence check 
```{r confidence check, echo=FALSE}

checkdf <- left_join(names, confidence)
# for some reason Beaver cave beetle got replicated so removing the row

checkdf <- checkdf[-which(is.na(checkdf$Initiatives_confidence_measure)),]

checkdf <- checkdf %>% select(scientific_name, common_name, Initiatives_confidence_measure, partners_confidence_measure)

checkdf <- checkdf %>%  mutate(good = case_when(grepl("RC", partners_confidence_measure, ignore.case = TRUE) ~ 1))  %>% 
  replace(is.na(.), 0)

checkdf <- checkdf %>%  mutate(some_missing = case_when(grepl("MI", partners_confidence_measure, ignore.case = TRUE) ~ 1))  %>% 
  replace(is.na(.), 0) 

checkdf <- checkdf %>%  mutate(okay  = good + some_missing)  # Finding all cases 


# now for partners only going to create two new columns to subset 

useme <- full_join(reg_partners, checkdf)


good <- useme[which(useme$good == 1),]
hist(good$NoHCPS_count)
good <- good %>% select(scientific_name:private_land_proportion, NoHCPS_count)
lma <- lm(log(NoHCPS_count) ~ log(range_area) + plant  + total_threats + private_land_proportion,data = good)
summary(lma)

okay <- useme[which(useme$okay == 1),]
hist(okay$NoHCPS_count)
okay <- okay %>% select(scientific_name:private_land_proportion, NoHCPS_count)
lmb <- lm(log(NoHCPS_count) ~ log(range_area) + plant  + total_threats + private_land_proportion,data = okay)
summary(lmb)


#lm1 <- lm(log(NoHCPS_count) ~ range_area + plant  + total_threats,data = good)
#lm4 <- lm(log(NoHCPS_count) ~ log(range_area) + plant  + total_threats + Big_Pg_count,data = good)
#lm10 <- lm(log(NoHCPS_count) ~ log(range_area) + plant  + total_threats + private_land_proportion,data = good)
#lm11 <- lm(log(NoHCPS_count) ~ log(range_area) + plant  + total_threats + weighted_rural,data = good)
#lm12 <- lm(log(NoHCPS_count) ~ log(range_area) + plant  + total_threats + private_land_proportion + month_12,data = good)
#lm13 <- lm(log(NoHCPS_count) ~ log(range_area) + plant  + total_threats + private_land_proportion + wd_proposed,data = good)
#lm14 <- lm(log(NoHCPS_count) ~ log(range_area) + plant  + total_threats + private_land_proportion + wd_proposed + month_12,data = good)
#lm15 <- lm(log(NoHCPS_count) ~ log(range_area) + plant  + total_threats + private_land_proportion + Big_Pg_count,data = good)


#stargazer(lm1, lm4, lm10, lm11, lm12, lm13, lm14, lm15, type = "html", title = "Partners_models", align = TRUE, out = "output/Sensitivity_analysis.html", # AIC isn't calculated for lm models so adding manually
#          add.lines=list(c("AIC", round(AIC(lm1),1), round(AIC(lm4),1), round(AIC(lm10),1), round(AIC(lm11),1), round(AIC(lm12),1), round(AIC(lm13),1), round(AIC(lm14),1), round(AIC(lm15),1)  ))) 

```





test relationship between number of initiatives and number of partners 
```{r, include = FALSE, echo = FALSE, eval=FALSE,}
test <- full_join(normal_partner_count, names) 

test2 <- test %>% full_join(no_init_per_sp_2, by = "common_name")
names(test2) <- c("scientific_name", "part"        ,     "common_name"   ,  "initi")

plot(test2$initi ~ test2$part)

```


Q - how many agreement documents are we missing 
```{r eval=FALSE, include = F}
question <- sub_initiatves_partners

normal_partner_count <- question %>% group_by(scientific_name, RowSpecInfo, Agreement_Name) %>% 
  distinct(DoWeHaveDoc) %>%  summarise(n(DoWeHaveDoc)) 

```



```{r eval=F, include = F}

####### scrap work 

taxa2 <- taxa %>% melt(id = c("actionresults", "vert_vs_invert"))

taxa_pivot <- taxa %>% pivot_wider(values_from = actionresults, names_from = vert_vs_invert)

taxa_pivot <- taxa_pivot[,c(24:26)]

# cast the melted data
# cast(data, formula, function)

trial <- taxa_pivot %>% distinct() %>% summarise(n())

subjmeans <- cast(taxa_pivot, P~I, sum)

taxa_pivot_two <- taxa_pivot %>% pivot_longer()


#Scrap work - missing [~10] species that need to get data on from Tyler 


min_tdata <- tdata[,c(3,4,18)]

missing <- full_join(min_tdata, outcomes)

```
