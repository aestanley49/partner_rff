---
title: "figuresproductionforthesis"
author: "Annabelle"
date: "April 16, 2020"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

Notes
The adjacency matrix isn't updating?? I have more partners than I should.. 

```{r load data, include=FALSE, echo=FALSE}
#file setup 
DataSource <- "./data" # input raw dataset goes here
output.dir <-"./output" # output dataset writes to here
functions.dir <- "./functions" # directory for functions 

source(file.path(functions.dir,'FormatData.R')) # any functions that are called up by this markdown document need to be sourced here

#packages
library(circlize)
library(janitor) #need for function FormatData to run 
library(tidyverse) #need for function FormatData to run 
library(tibble)
library(readr)
library(skimr)
library(igraph)
library(knitr) #for making tables form kable 
library(kableExtra)
library(reshape2)
library(tidytext) #suggested in github helpform for an error
library(data.table)

#data 
RawData <- read_csv(paste(DataSource,"/AS9_codingdata.csv", sep = ""))
PartnerData <- FormatData(RawData)
adjmatrix <- read_csv("/usr/local/bin/store/partner_rff/output/adjacencymatrix.csv")
```


<br>

Thoughts: 
Different matrix types that could convert to graphs
- currently have a symetry matrix (adj)
- want an diagonal matrix?
- would creating upper trianglar matrix remove redundancies? Unclear how currently being graphed 
--> also need to simplify (remove 0s?)

Read through documentation around graphic creation to see how produced - anything that can go in code to change output?? 

## new idea
  ### symatry to identiy matrix - melt() then graph? for counts of species for each patner greater than 1? 

PartnerData: chordDiagram
```{r PartnerData:chordDiagram, eval=FALSE, include=FALSE, echo= FALSE}
changeme <- PartnerData
data <- changeme[,-c(1,3)]
chordDiagram(data) #this doesn't work right now 

```



Adjacency matrix: chordDiagram
```{r Adjacency matrix:chordDiagram}
dfadj <- melt(adjmatrix) #changes matrix to dataframe
dfadj <- dfadj %>% filter(value > 1) #remove all partner less than 1

#see if can remove the count of how many species a partner is working on (loop going back to self)
#to do this can remove row where first two columns have same character
noextra <- dfadj %>% filter(X1 != variable)
chordDiagram(noextra)

two <- noextra %>% filter(value > 2) #remove all partners less than 2 
chordDiagram(two, scale = TRUE)
## so their still seems to be some redundancy where the is a line going from parter a to partner b and another line (samve value) going from b back to a 
### scale = TRUE seems to fix this? 
chordDiagram(two, scale = FALSE)
### with scale - "value represents the fraction of the interaction going to one other secto"

#labels - need to pre-allocate empty track and costomize later (going to be a pain for each so just do later?)

#scrapwork to try and figure out noextra
take <- dfadj[!duplicated(dfadj[,c("X1", "variable")]),] #didn't do anything
#data %>% distinct(x,y)
#ugh <- dfadj %>% distinct(.data =dfadj, .keep_all = FALSE)
trans <- t(dfadj) #can't figure out how to delete column values that are the same
ttrans <- t(trans)

```


Adjacency matrix: igraph 
```{r Adjacency matrix:igraph}

```


```{r eastcoast_westcoast_partnercomparison}
## there was something in chord diagram about keeping comparing two diagrams (keeps scale the same fro each?)
# I think I need to make a new dataset for this - pull togther from centroids data where mississippi is dividing line? 
```


<br>

tables and graphs to include 


```{r partners per species}
PartnerData$TotalPartners <- rowSums(PartnerData[,-c(1:3)])

hist(PartnerData$TotalPartners,
     xlab ="Number of Partners Working on a Species",
     breaks = 60,
     main = NULL)

```

**why is NRCS and Natural Resources Conservation Service on here? I checked the code and no repeats...???**

```{r no species each partner is working on}
#this is just the diagonal matrix from adj matrix 
graphme <- adjmatrix
graphme <- graphme %>% melt()
graphme <- graphme %>% filter(X1 == variable)
graphme <- graphme[,-c(1)] #removed duplicate names
#all partners
ggplot(data = graphme) + geom_col(mapping = aes(x=variable, y=value))
g_one <- graphme %>% filter(value >1)
ggplot(data = g_one, mapping = aes(x=variable, y=value)) + geom_col() + theme(axis.text.x = element_text(angle = 90)) + scale_y_continuous(name ="Number of Species", limits=c(0,45)) + scale_x_discrete(name ="Name of Partner")
```

Note, even with the number of partnerships in the adj matrix (right now too many, should only be aprox 200) this script will still run 
```{r no partnerships for each partner}
#going to convert all values that are greater than 1 to one so not double counting 
# then subtract diagonal 
#then add 
pdata <- adjmatrix
newmat <- pdata[1,]
newmat[,1] <- "empty" 
#add empty row with same no of columns to combine with current matrix 
newMatrix <- rbind(newmat, pdata)

newMatrix <- newMatrix %>% mutate_if(is.numeric, ~1 * (. != 0))

diag(newMatrix)=0
#delete top (empty) row 
newMatrix <- newMatrix[-1,] ##I think this matrix is worth keeping (all numers now 1s and 0s )
asnum <- newMatrix[,-c(1)]
names <- newMatrix[,c(1)]
rssum <- rowSums(newMatrix[,c(-1)])
newdf <- cbind(names, rssum) ## yay I did it!! 

## now going to try and filter

explore <- newdf 
explore <- explore %>% arrange(-rssum)
(explore[c(1:4),])

#still feeds mis-represented 

#summary count of the number of partnership for each partner (how many partner have 2 parnters, 3 etc? ) 
ggplot(data = explore, mapping = aes(x=rssum)) + geom_bar() + scale_x_continuous(name ="Number of Partners", limits=c(-1,175)) + scale_y_continuous(name ="Frequency", limits=c(0,50))

#because data is scewed with giant outlier, have recalibrated to show what majority of the data looks like 
filt <- explore %>% filter(rssum < 50) 
ggplot(data = filt, mapping = aes(x=rssum)) + geom_bar() + scale_x_continuous(name ="Number of Partners", limits=c(-1,40)) + scale_y_continuous(name ="Frequency", limits=c(0,20))

#need to get r-values in 
```


*** need to get the combo to work inorder to set up #species/partner and #partners/partners **

```{r combined?, echo=FALSE, include=FALSE, eval=FALSE}
#x-axis: # partners?species, y-axis: species/partner, size = #partnerships/partner 
#(can also try swtiching and see how data is dispersed)

#partnerperspecies <- PartnerData$TotalPartners

specesperpartner <- colSums(PartnerData[,-c(1:3)])
speperpart <- t(specesperpartner)
sppart <- t(speperpart) #trying to get partner names as row names
number_of_species_per_partner <- sppart[-c(199),] #gets werid when I delete the bottom row
number_of_species_per_partner <- t(number_of_species_per_partner)
number_of_species_per_partner <- t(number_of_species_per_partner) #this works
#making rownames a column so can join later 
number_of_species_per_partner <- as.data.frame(number_of_species_per_partner)
number_of_species_per_partner <- number_of_species_per_partner %>% rownames_to_column(var = "X1")
number_of_species_per_partner <- number_of_species_per_partner %>% rename("species_per_partner" = V1) 


View(number_of_species_per_partner)
explore <- explore %>% rename("partnerships_per_partner" = rssum)

## the joins aren't working - just getting partner names then replicated row columns
and <- explore %>% left_join(number_of_species_per_partner, by = NULL)
#or <- explore %>% full_join(explore, number_of_species_per_partner, by = "X1")

#try and circumvent this by arranging both in the same order and then combining by add column 
# this also isn't working 
#####number_of_species_per_partner <- number_of_species_per_partner %>% arrange(number_of_species_per_partner)

#####number_of_species_per_partner <- sort(number_of_species_per_partner$X1)
#####explore <- sort(explore$X1)

#not sure what I was trying to plot before

and1 <- and[-which(is.na(and$species_per_partner)),]
length()

ggplot(data = and1, mapping = aes(x=species_per_partner, y=partnerships_per_partner)) + geom_point()

#add labels 

ggplot(data = explore, mapping = aes(x=number_of_species_per_partner, y=Number_of_partnerships_per_partner)) + geom_point() + geom_label(mapping = aes(x=number_of_species_per_partner, y=Number_of_partnerships_per_partner, label = X1))


```



```{r partner-partner old code, eval = FALSE, include = FALSE, echo = FALSE}
## this is old code - counts redundancies 
## thoguht I just needed to subtract diagonal then add 

ppdata <- adjmatrix
nnewmat <- ppdata[1,]
nnewmat[,1] <- "empty" 
#add empty row with same no of columns to combine with current matrix 
nnewMatrix <- rbind(newmat, pdata)

diag(nnewMatrix)=0
#delete top (empty) row 
nnewMatrix <- nnewMatrix[-1,]

aasnum <- nnewMatrix[,-c(1)]

csum <- colSums(aasnum, na.rm = TRUE)

newdf2 <- cbind(names, rsum)

#################################################

# There is still an issue here, where a partner that worked on one species, but had more parnterships in that conservation agreement looks like it has more partners than another partner that worked on more than one species with less partners. 
# going to try and adjust for that here by dividing sum of all / sum of 1s 


combo <- newdf2$rsum/ newdf$rssum

final <- cbind(names, combo)

#now have fractional amount that isn't really significiant?
```


```{r regression_correlation_matrix}
#need to get r-values in 
```


<br>

Supplementary material 

### name assumptions

### regression 

```{r}

```

For changing text size - https://stackoverflow.com/questions/40840986/knitrkable-is-there-a-way-to-reduce-the-font-size


```{r list of species}
#list of species with partners working on them 
pdata <- PartnerData[,c(1:3)]
kable(pdata) ##getting werid error here, look into using a different table format? 
```


```{r list of partners}
#kable(colSums(PartnerData[,-c(1:3)]))
#kable(table(colSums(PartnerData[,-c(1:3)])))

name <- colSums(PartnerData[,-c(1:3)])
name %>%
  kable("html") %>% 
  kable_styling(font_size = 7)

```


west coast v east coast 
  #### variable okay produced in RegressionPredictoExploration range chunk 
removing all 0s columns not working 
```{r east and west adj matrix}
west <- okay %>% filter(geo == TRUE)
west <- west [,c(1,3)]
west <- west %>% left_join(PartnerData, by = "scientific_name")
nzwest <- west[,-c(1:4)][,colSums(west[,-c(1:4)])>=1] #removed columns with all 0s
dim(west)
nzwest <- as.matrix(nzwest) #prep for making adj matrix
wajmat <- t(nzwest) %*% nzwest #new adjmat
tidyweajmat <- as_tibble(wajmat, rownames = "id")


east <- okay %>% filter(geo == FALSE)
east <- east [,c(1,3)]
east <- east %>% left_join(PartnerData, by = "scientific_name") 
nzeast <- east[,-c(1:4)][,colSums(east[,-c(1:4)])>=1]
dim(nzeast)
nzeast <- as.matrix(nzeast) #prep for making adj matrix
eajmat <- t(nzeast) %*% nzeast #new adjmat
#need to change from matrix to tidyr 
#need to change to tidyverse for later code
tidyeajmat <- as_tibble(eajmat, rownames = "id")

```

### Figure 3: A subsection of the total dataframe to show the number of species a partner is working on 
##### Planning to use the second of two graphs for paper 
```{r no species WEST}
#this is just the diagonal matrix from adj matrix 
graphme <- wajmat
graphme <- graphme %>% melt()
graphme <- graphme %>% filter(Var1 == Var2)
graphme <- graphme[,-c(1)] #removed duplicate names
#all partners
ggplot(data = graphme) + geom_col(mapping = aes(x=Var2, y=value))
g_one <- graphme %>% filter(value >1)
ggplot(data = g_one, mapping = aes(x=Var2, y=value)) + geom_col() + theme(axis.text.x = element_text(angle = 90)) + scale_y_continuous(name ="Number of Species", limits=c(0,45)) + scale_x_discrete(name ="Name of Partner")
```

Having some issues here with rotating text on line 345
```{r no species EAST}
#this is just the diagonal matrix from adj matrix 
graphme <- eajmat
graphme <- graphme %>% melt()
graphme <- graphme %>% filter(Var1 == Var2)
graphme <- graphme[,-c(1)] #removed duplicate names
#all partners
ggplot(data = graphme) + geom_col(mapping = aes(x=Var2, y=value)) + theme(axis.text.x = element_text(angle = 90))
g_one <- graphme %>% filter(value >1)
ggplot(data = g_one, mapping = aes(x=Var2, y=value)) + geom_col() + theme(axis.text.x = element_text(angle = 90)) + scale_y_continuous(name ="Number of Species", limits=c(0,10)) + scale_x_discrete(name ="Name of Partner")
```


```{r no partnerships for each partner WEST}
#going to convert all values that are greater than 1 to one so not double counting 
# then subtract diagonal 
#then add 
pdata <- tidyweajmat
newmat <- pdata[1,]
newmat[,1] <- "empty" 
#add empty row with same no of columns to combine with current matrix 
newMatrix <- rbind(newmat, pdata)
class(newmat)
newMatrix <- newMatrix %>% mutate_if(is.numeric, ~1 * (. != 0))

diag(newMatrix)=0
#delete top (empty) row 
newMatrix <- newMatrix[-1,] ##I think this matrix is worth keeping (all numers now 1s and 0s )
asnum <- newMatrix[,-c(1)]
names <- newMatrix[,c(1)]
rssum <- rowSums(newMatrix[,c(-1)])
newdfwest <- cbind(names, rssum) ## yay I did it!! 

## now going to try and filter

explore <- newdfwest
explore <- explore %>% arrange(-rssum)
(explore[c(1:4),])

#still feeds mis-represented 

#summary count of the number of partnership for each partner (how many partner have 2 parnters, 3 etc? ) 
ggplot(data = explore, mapping = aes(x=rssum)) + geom_bar() + scale_x_continuous(name ="Number of Partners on the West Coast", limits=c(-1,100)) + scale_y_continuous(name ="Frequency", limits=c(0,20))

#don't need the filter but this shows that there are two values that you can't see on the other graph
filt <- explore %>% filter(rssum > 50) 
ggplot(data = filt, mapping = aes(x=rssum)) + geom_bar() + scale_x_continuous(name ="Number of Partners on the West Coast", limits=c(50,100)) + scale_y_continuous(name ="Frequency", limits=c(0,20))
```



```{r no partnerships for each partner EAST}
#going to convert all values that are greater than 1 to one so not double counting 
# then subtract diagonal 
#then add 
pdata <- tidyeajmat
newmat <- pdata[1,]
newmat[,1] <- "empty" 
#add empty row with same no of columns to combine with current matrix 
newMatrix <- rbind(newmat, pdata)
class(newmat)
newMatrix <- newMatrix %>% mutate_if(is.numeric, ~1 * (. != 0))

diag(newMatrix)=0
#delete top (empty) row 
newMatrix <- newMatrix[-1,] ##I think this matrix is worth keeping (all numers now 1s and 0s )
asnum <- newMatrix[,-c(1)]
names <- newMatrix[,c(1)]
rssum <- rowSums(newMatrix[,c(-1)])
newdfeast <- cbind(names, rssum) ## yay I did it!! 

## now going to try and filter

explore <- newdfeast
explore <- explore %>% arrange(-rssum)
(explore[c(1:4),])

#still feeds mis-represented 

#summary count of the number of partnership for each partner (how many partner have 2 parnters, 3 etc? ) 
ggplot(data = explore, mapping = aes(x=rssum)) + geom_bar() + scale_x_continuous(name ="Number of Partners on the East Coast", limits=c(-1,75)) + scale_y_continuous(name ="Frequency", limits=c(0,50))

## I don'g think you need the filter 
#because data is scewed with giant outlier, have recalibrated to show what majority of the data looks like 
filt <- explore %>% filter(rssum < 50) 
ggplot(data = filt, mapping = aes(x=rssum)) + geom_bar() + scale_x_continuous(name ="Number of Partners", limits=c(-1,50)) + scale_y_continuous(name ="Frequency", limits=c(0,20))
```


Next combine into one graph?? 
